<!-- START OF FILE 海战棋v4_final_fix.html -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>海战棋 (by Arthur) - V4 Intelligent</title>
    <style>
        /* --- 1. 全局设计 --- */
        :root {
            --bg-paper: #f9f9f9;
            --ink-color: #333;
            --red-pen: #d32f2f; 
            --blue-pen: #304ffe; 
            --shadow-hard: 3px 3px 0px rgba(0,0,0,0.08);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }

        body {
            font-family: "Courier New", Courier, "Microsoft YaHei", monospace;
            background-color: var(--bg-paper);
            margin: 0; padding: 0; 
            min-height: 100vh;
            color: var(--ink-color);
            overflow-x: hidden;
            overflow-y: auto; 
            display: flex;
            flex-direction: column;
        }

        /* --- 2. 头部 --- */
        header {
            flex-shrink: 0; background: #fff; border-bottom: 3px solid var(--ink-color);
            padding: 10px 20px; display: flex; justify-content: center; align-items: center;
            z-index: 50; box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            position: sticky; top: 0; 
        }
        h1 { margin: 0; font-size: 1.4rem; font-weight: 900; letter-spacing: 2px; text-transform: uppercase; }
        .btn-help { border: 2px solid var(--ink-color); background: transparent; border-radius: 50%; width: 28px; height: 28px; font-weight: 900; margin-left: 15px; cursor: pointer; font-size: 1.1rem; }

        /* --- 3. 游戏主容器 --- */
        #game-container {
            flex: 1; 
            display: flex; justify-content: center; align-items: flex-start;
            padding: 20px; gap: 40px; flex-wrap: wrap; align-content: flex-start;
            padding-bottom: 100px; 
        }

        .visually-hidden { display: none !important; }

        @media (max-width: 768px) {
            #game-container {
                display: block; 
                padding: 10px; 
                padding-bottom: 320px; 
            }
            .board-wrapper { width: 100%; max-width: 400px; margin: 0 auto 30px auto; }
            #dock-container { position: fixed; bottom: 0; left: 0; right: 0; z-index: 60; box-shadow: 0 -4px 15px rgba(0,0,0,0.1); }
        }

        @media (max-height: 600px) and (orientation: landscape) {
            #game-container { padding-bottom: 40px; display: flex; }
            #dock-container { position: relative; bottom: auto; border-top: 3px solid var(--ink-color); box-shadow: none; margin-top: 20px; }
            header { position: relative; } 
        }

        @media (min-width: 769px) {
            .board-wrapper { width: 400px; }
            #dock-container { position: sticky; bottom: 0; border-top: 3px solid var(--ink-color); }
        }

        /* --- 4. 棋盘组件 --- */
        .board-wrapper {
            background: #fff; padding: 4px; 
            border: 3px solid var(--ink-color);
            border-radius: 2px 2px 5px 3px; 
            box-shadow: var(--shadow-hard); position: relative;
            transition: transform 0.2s;
        }
        .board-wrapper::before {
            content: ''; position: absolute; top: -8px; left: 10px; width: 80px; height: 8px;
            background: #fff; border: 3px solid var(--ink-color); border-bottom: none; 
            border-radius: 5px 5px 0 0;
        }
        
        .active-turn { transform: translateY(-4px); box-shadow: 8px 8px 0 rgba(0,0,0,0.15); z-index: 10; border-color: #000; }
        
        .red-theme { color: var(--red-pen); border-color: var(--red-pen); }
        .red-theme::before { border-color: var(--red-pen); }
        .blue-theme { color: var(--blue-pen); border-color: var(--blue-pen); }
        .blue-theme::before { border-color: var(--blue-pen); }

        .board-header { display: flex; justify-content: space-between; font-weight: 800; margin-bottom: 6px; font-size: 1rem; padding: 0 4px; }

        .board {
            display: grid; grid-template-columns: repeat(10, 1fr); width: 100%; aspect-ratio: 1 / 1;
            border: 2px solid var(--ink-color); position: relative; transform-style: flat;
        }
        .cell { border: 1px solid rgba(0,0,0,0.06); position: relative; cursor: crosshair; }

        /* --- 5. 舰艇样式 SVG --- */
        .ship-shape {
            position: absolute; 
            top: -1px; bottom: -1px; left: -1px; right: -1px;
            z-index: 5; pointer-events: none;
            background-size: 100% 100%; background-repeat: no-repeat; display: none; 
        }
        .in-dock .ship-shape, .board.show-ships .cell.ship .ship-shape, .cell.ship.sunk .ship-shape { display: block; }

        /* 基础形状 */
        .shape-bow { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='none'%3E%3Cpath d='M10 102 L50 5 L90 102' fill='white' stroke='%23333' stroke-width='6' stroke-linejoin='round'/%3E%3Cpath d='M50 15 L50 60' stroke='%23333' stroke-width='4'/%3E%3Ccircle cx='50' cy='80' r='10' stroke='%23333' stroke-width='3' fill='none'/%3E%3C/svg%3E"); }
        .shape-body { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='none'%3E%3Crect x='0' y='-5' width='100' height='110' fill='white' stroke='none'/%3E%3Cline x1='10' y1='-5' x2='10' y2='105' stroke='%23333' stroke-width='6'/%3E%3Cline x1='90' y1='-5' x2='90' y2='105' stroke='%23333' stroke-width='6'/%3E%3Ccircle cx='50' cy='50' r='18' stroke='%23333' stroke-width='4' fill='none'/%3E%3Cline x1='10' y1='20' x2='90' y2='20' stroke='%23333' stroke-width='2'/%3E%3Cline x1='10' y1='80' x2='90' y2='80' stroke='%23333' stroke-width='2'/%3E%3C/svg%3E"); }
        .shape-stern { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='none'%3E%3Cpath d='M10 -2 L10 50 Q50 105 90 50 L90 -2' fill='white' stroke='%23333' stroke-width='6'/%3E%3Cline x1='25' y1='20' x2='75' y2='20' stroke='%23333' stroke-width='3'/%3E%3Cline x1='35' y1='40' x2='65' y2='40' stroke='%23333' stroke-width='3'/%3E%3C/svg%3E"); }

        /* 蓝色主题 (Blue Pen) */
        .blue-theme .shape-bow, .board-wrapper.blue-theme .cell .shape-bow {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='none'%3E%3Cpath d='M10 102 L50 5 L90 102' fill='white' stroke='%23304ffe' stroke-width='6' stroke-linejoin='round'/%3E%3Cpath d='M50 15 L50 60' stroke='%23304ffe' stroke-width='4'/%3E%3Ccircle cx='50' cy='80' r='10' stroke='%23304ffe' stroke-width='3' fill='none'/%3E%3C/svg%3E");
        }
        .blue-theme .shape-body, .board-wrapper.blue-theme .cell .shape-body {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='none'%3E%3Crect x='0' y='-5' width='100' height='110' fill='white' stroke='none'/%3E%3Cline x1='10' y1='-5' x2='10' y2='105' stroke='%23304ffe' stroke-width='6'/%3E%3Cline x1='90' y1='-5' x2='90' y2='105' stroke='%23304ffe' stroke-width='6'/%3E%3Ccircle cx='50' cy='50' r='18' stroke='%23304ffe' stroke-width='4' fill='none'/%3E%3Cline x1='10' y1='20' x2='90' y2='20' stroke='%23304ffe' stroke-width='2'/%3E%3Cline x1='10' y1='80' x2='90' y2='80' stroke='%23304ffe' stroke-width='2'/%3E%3C/svg%3E");
        }
        .blue-theme .shape-stern, .board-wrapper.blue-theme .cell .shape-stern {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='none'%3E%3Cpath d='M10 -2 L10 50 Q50 105 90 50 L90 -2' fill='white' stroke='%23304ffe' stroke-width='6'/%3E%3Cline x1='25' y1='20' x2='75' y2='20' stroke='%23304ffe' stroke-width='3'/%3E%3Cline x1='35' y1='40' x2='65' y2='40' stroke='%23304ffe' stroke-width='3'/%3E%3C/svg%3E");
        }

        /* 红色主题 (Red Pen) */
        .red-theme .shape-bow, .board-wrapper.red-theme .cell .shape-bow {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='none'%3E%3Cpath d='M10 102 L50 5 L90 102' fill='white' stroke='%23d32f2f' stroke-width='6' stroke-linejoin='round'/%3E%3Cpath d='M50 15 L50 60' stroke='%23d32f2f' stroke-width='4'/%3E%3Ccircle cx='50' cy='80' r='10' stroke='%23d32f2f' stroke-width='3' fill='none'/%3E%3C/svg%3E");
        }
        .red-theme .shape-body, .board-wrapper.red-theme .cell .shape-body {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='none'%3E%3Crect x='0' y='-5' width='100' height='110' fill='white' stroke='none'/%3E%3Cline x1='10' y1='-5' x2='10' y2='105' stroke='%23d32f2f' stroke-width='6'/%3E%3Cline x1='90' y1='-5' x2='90' y2='105' stroke='%23d32f2f' stroke-width='6'/%3E%3Ccircle cx='50' cy='50' r='18' stroke='%23d32f2f' stroke-width='4' fill='none'/%3E%3Cline x1='10' y1='20' x2='90' y2='20' stroke='%23d32f2f' stroke-width='2'/%3E%3Cline x1='10' y1='80' x2='90' y2='80' stroke='%23d32f2f' stroke-width='2'/%3E%3C/svg%3E");
        }
        .red-theme .shape-stern, .board-wrapper.red-theme .cell .shape-stern {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='none'%3E%3Cpath d='M10 -2 L10 50 Q50 105 90 50 L90 -2' fill='white' stroke='%23d32f2f' stroke-width='6'/%3E%3Cline x1='25' y1='20' x2='75' y2='20' stroke='%23d32f2f' stroke-width='3'/%3E%3Cline x1='35' y1='40' x2='65' y2='40' stroke='%23d32f2f' stroke-width='3'/%3E%3C/svg%3E");
        }

        .rot-90 { transform: rotate(-90deg); top: -1px; bottom: -1px; left: -1px; right: -1px; }
        .in-dock .ship-shape { transform: rotate(-90deg); top: 0; bottom: 0; left: -5%; right: -5%; }

        /* --- 6. 状态标记 --- */
        .cell.hit::before {
            content: ''; position: absolute; top: 10%; left: 10%; width: 80%; height: 80%; border-radius: 50%; z-index: 20;
            background: radial-gradient(circle at 35% 35%, rgba(255,255,255,0.9) 0%, rgba(255,235,59,0.9) 25%, rgba(255,87,34,0.8) 50%, rgba(255,0,0,0) 70%);
            mix-blend-mode: multiply; filter: drop-shadow(0 0 2px #ff5722); animation: firePulse 0.8s infinite alternate ease-in-out;
        }
        .cell.hit::after {
            content: ''; position: absolute; top: 20%; left: 20%; width: 60%; height: 60%;
            background: radial-gradient(circle, #fff 10%, #ffeb3b 60%, transparent 70%);
            border-radius: 50%; z-index: 21; opacity: 0.7; animation: fireFlicker 0.4s infinite alternate-reverse; display: block;
        }
        @keyframes firePulse { 0% { transform: scale(0.9) translate(0, 2px); opacity: 0.8; } 100% { transform: scale(1.1) translate(0, -2px); opacity: 1; } }
        @keyframes fireFlicker { 0% { transform: scale(0.8) skewX(5deg); } 100% { transform: scale(1.0) skewX(-5deg); } }

        .cell.ship.sunk .ship-shape { filter: grayscale(100%) opacity(0.6); z-index: 15; }
        .cell.ship.sunk .sunk-mark {
            position: absolute; inset: 0;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' stroke='%23d32f2f' stroke-width='3' fill='none'%3E%3Cline x1='4' y1='4' x2='20' y2='20'/%3E%3Cline x1='20' y1='4' x2='4' y2='20'/%3E%3C/svg%3E");
            z-index: 30; opacity: 1; display: block;
        }
        .cell.sunk.hit::before, .cell.sunk.hit::after { display: none; }

        .cell.miss::after {
            content: ''; position: absolute; top: 38%; left: 38%; width: 24%; height: 24%;
            background: #b0bec5; border-radius: 50%; z-index: 5; animation: none; transform: none;
        }
        .boom {
            position: absolute; inset: -50%; pointer-events: none; z-index: 40;
            background: radial-gradient(circle, #ffeb3b 10%, #ff5722 40%, transparent 70%);
            border-radius: 50%; opacity: 0; animation: explode 0.4s ease-out;
        }
        @keyframes explode { 0% { transform: scale(0.1); opacity: 1; } 100% { transform: scale(1.5); opacity: 0; } }

        /* --- 7. 底部控制区 --- */
        #dock-container {
            flex-shrink: 0; width: 100%; background: #fff; padding: 10px;
            display: flex; flex-direction: column; align-items: center;
            border-top: 3px solid var(--ink-color);
        }
        #message-area { 
            font-weight: 800; margin-bottom: 8px; color: var(--red-pen); 
            min-height: 20px; font-size: 1rem; text-align: center;
        }
        #placement-ui { width: 100%; display: flex; flex-direction: column; align-items: center; }
        #ship-dock { display: flex; gap: 8px; margin-bottom: 8px; justify-content: center; }
        .controls-row { display: flex; gap: 10px; justify-content: center; width: 100%; margin-top: 2px; }

        @media (min-width: 769px) { .controls-row { max-width: 600px; } #ship-dock { flex-wrap: nowrap; } .btn { flex: 1; } }
        @media (max-width: 768px) {
            #ship-dock { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; width: 100%; }
            .controls-row {
                display: grid; grid-template-columns: 1fr 1fr 1fr; 
                grid-template-areas: "rot undo reset" "rand confirm confirm";
                gap: 8px; width: 100%;
            }
            #btn-rot { grid-area: rot; } #btn-undo { grid-area: undo; } #btn-reset { grid-area: reset; }
            #btn-rand { grid-area: rand; } #btn-confirm { grid-area: confirm; }
        }

        .dock-ship {
            display: flex; align-items: center; justify-content: center;
            padding: 4px; border: 1px solid #ccc; border-radius: 3px; 
            background: #f0f0f0; cursor: pointer; transition: 0.1s;
        }
        .red-theme .dock-ship.selected { background: #fff; border: 2px solid var(--red-pen); transform: scale(1.02); }
        .blue-theme .dock-ship.selected { background: #fff; border: 2px solid var(--blue-pen); transform: scale(1.02); }

        .dock-cell { width: 18px; height: 18px; position: relative; }
        .dock-cell:last-child { margin-right: 0; }

        button.btn {
            background: #fff; border: 2px solid var(--ink-color); padding: 8px 0;
            font-family: inherit; font-weight: 800; cursor: pointer;
            box-shadow: 2px 2px 0 var(--ink-color); font-size: 0.85rem; border-radius: 2px;
            white-space: nowrap;
        }
        button.btn:active:not(:disabled) { transform: translate(1px, 1px); box-shadow: 1px 1px 0 var(--ink-color); }
        button.btn:disabled { opacity: 0.5; background: #eee; box-shadow: none; transform: translate(1px, 1px); }
        
        #btn-rot { background: #e3f2fd; color: #1565c0; }
        #btn-confirm { background: #e8f5e9; color: #2e7d32; font-weight: 900; }
        .btn-action { background: #fff; }

        /* --- 8. 模态框 --- */
        .modal-overlay {
            position: fixed; inset: 0; background: rgba(44, 62, 80, 0.95);
            display: flex; justify-content: center; align-items: center; z-index: 100;
        }
        .hidden { display: none !important; }
        .modal-content {
            background: #fff; border: 4px solid #000; padding: 25px;
            width: 90%; max-width: 450px; text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5); pointer-events: auto; 
        }
        .modal-title { font-size: 1.6rem; margin-bottom: 20px; border-bottom: 2px solid #000; padding-bottom: 10px; font-weight: 900; }
        .rules-container { text-align: left; max-height: 60vh; overflow-y: auto; padding: 0 10px; }
        .rule-block { margin-bottom: 15px; }
        .rule-title { font-weight: 900; color: var(--red-pen); font-size: 1.05rem; margin-bottom: 4px; display: flex; align-items: center; }
        .rule-title::before { content: '■'; font-size: 0.6em; margin-right: 6px; color: var(--ink-color); }
        .rule-desc { margin: 0; padding-left: 18px; font-size: 0.95rem; color: #555; line-height: 1.5; }
        .rule-highlight { color: #000; font-weight: bold; background: #fff8e1; padding: 0 4px; }
        .rule-close-hint { margin-top: 20px; font-size: 0.9rem; color: #777; font-weight: bold; border-top: 1px dashed #ccc; padding-top: 10px;}
    </style>
</head>
<body>

<header>
    <h1>海战棋 (by Arthur)</h1>
    <button class="btn-help" onclick="showRules()">?</button>
</header>

<div id="game-container">
    <div id="red-wrapper" class="board-wrapper red-theme">
        <div class="board-header">
            <span id="red-name">红方</span>
            <span id="red-score">战舰: 5</span>
        </div>
        <div id="red-board" class="board"></div>
    </div>
    <div id="blue-wrapper" class="board-wrapper blue-theme">
        <div class="board-header">
            <span id="blue-name">蓝方</span>
            <span id="blue-score">战舰: 5</span>
        </div>
        <div id="blue-board" class="board"></div>
    </div>
</div>

<div id="dock-container">
    <div id="message-area">等待开始...</div>
    
    <div id="placement-ui" class="hidden">
        <div id="ship-dock"></div>
        <div class="controls-row">
            <button class="btn" id="btn-rot" onclick="toggleOrientation()">方向: 横向</button>
            <button class="btn btn-action" id="btn-undo" onclick="undoLastShip()">撤回</button>
            <button class="btn btn-action" id="btn-reset" onclick="resetPlacement()">重置</button>
            <button class="btn btn-action" id="btn-rand" onclick="randomPlacement()">随机</button>
            <button class="btn" id="btn-confirm" onclick="confirmPlacement()" disabled>确认部署</button>
        </div>
    </div>
    
    <button class="btn" id="btn-restart" style="display:none; max-width:200px; background:#e8f5e9; color:#2e7d32;" onclick="location.reload()">再来一局</button>
</div>

<div id="modal-menu" class="modal-overlay">
    <div class="modal-content">
        <div class="modal-title">作战指挥部</div>
        <button class="btn" style="margin-bottom:12px; padding:12px;" onclick="initGame('pve')">人机演习 (PvE)</button>
        <button class="btn" style="padding:12px;" onclick="initGame('pvp')">双人对决 (PvP)</button>
    </div>
</div>

<div id="modal-transition" class="modal-overlay hidden">
    <div class="modal-content">
        <h2 class="modal-title" style="color:var(--red-pen)">⚠️ 军事机密 ⚠️</h2>
        <p id="transition-msg" style="margin-bottom:20px; font-size:1.1rem; font-weight:bold;">...</p>
        <button class="btn" style="background:#e8f5e9; color:#2e7d32; padding:10px;" onclick="endTransition()">确认 / 继续</button>
    </div>
</div>

<div id="modal-rules" class="modal-overlay hidden" onclick="closeRules(event)">
    <div class="modal-content" onclick="event.stopPropagation()">
        <div class="modal-title">作战手册</div>
        <div class="rules-container">
            <div class="rule-block">
                <div class="rule-title">1. 部署阶段</div>
                <p class="rule-desc">选中底部舰艇，点击海域放置。利用【方向】按钮旋转舰艇。</p>
            </div>
            <div class="rule-block">
                <div class="rule-title">2. 索敌攻击</div>
                <p class="rule-desc">敌舰在未被击沉前处于<span class="rule-highlight">隐形状态</span>。击中会有燃烧标记，未命中显示水花。</p>
            </div>
            <div class="rule-block">
                <div class="rule-title">3. 连击机制</div>
                <p class="rule-desc">若<span class="rule-highlight">命中</span>敌舰，可继续攻击，直到未命中为止。</p>
            </div>
            <div class="rule-block">
                <div class="rule-title">4. 击沉与胜利</div>
                <p class="rule-desc">击沉舰艇后显示残骸与红叉。率先击沉敌方<span class="rule-highlight">5艘</span>战舰获胜。</p>
            </div>
        </div>
        <div class="rule-close-hint">（点击空白区域关闭）</div>
        <div style="margin-top:10px; text-align:right; font-size:0.8rem; color:#ccc;">开发者：ArthurZhu</div>
    </div>
</div>

<div id="modal-gameover" class="modal-overlay hidden">
    <div class="modal-content">
        <div class="modal-title" id="winner-title">战役结束</div>
        <p id="winner-msg" style="margin-bottom:20px; font-size:1.1rem;"></p>
        <button class="btn" style="padding:10px;" onclick="location.reload()">重新整编</button>
    </div>
</div>

<script>
    const CONFIG = { size: 10, ships: [5, 4, 3, 3, 2] };
    const STATE = {
        mode: null, phase: 'menu', turn: 'red', placing: 'red', isHorizontal: true, selectedShipId: null,
        redGrid: [], blueGrid: [], redShips: [], blueShips: [],
        pvePlayer: 'red',
        aiStack: [], // AI 待攻击队列
        nextTransitionAction: null
    };

    const els = {
        redBoard: document.getElementById('red-board'), blueBoard: document.getElementById('blue-board'),
        redWrapper: document.getElementById('red-wrapper'), blueWrapper: document.getElementById('blue-wrapper'),
        dock: document.getElementById('ship-dock'), placeUI: document.getElementById('placement-ui'),
        msg: document.getElementById('message-area'), btnConfirm: document.getElementById('btn-confirm'),
        modalMenu: document.getElementById('modal-menu'), modalTrans: document.getElementById('modal-transition'),
        modalOver: document.getElementById('modal-gameover')
    };

    function createShipShapeHTML(cellIndex, shipSize, isHorizontal) {
        const shape = document.createElement('div');
        shape.className = 'ship-shape';
        if (cellIndex === 0) shape.classList.add('shape-bow');
        else if (cellIndex === shipSize - 1) shape.classList.add('shape-stern');
        else shape.classList.add('shape-body');
        
        if (isHorizontal) shape.classList.add('rot-90');
        return shape;
    }

    function createGrid(el, gridData, owner) {
        el.innerHTML = '';
        for (let y=0; y<CONFIG.size; y++) {
            let row=[];
            for (let x=0; x<CONFIG.size; x++) {
                const cell = document.createElement('div');
                cell.className='cell'; cell.dataset.x=x; cell.dataset.y=y;
                cell.onclick = () => handleCellClick(x, y, owner);
                el.appendChild(cell); row.push(0);
            }
            gridData.push(row);
        }
    }

    function initGame(mode) {
        STATE.mode = mode; STATE.redGrid=[]; STATE.blueGrid=[]; STATE.redShips=[]; STATE.blueShips=[];
        createGrid(els.redBoard, STATE.redGrid, 'red'); createGrid(els.blueBoard, STATE.blueGrid, 'blue');
        els.modalMenu.classList.add('hidden');
        
        if(mode==='pve') {
            STATE.pvePlayer = Math.random()<0.5?'red':'blue';
            if(STATE.pvePlayer==='red') { document.getElementById('red-name').textContent="红方 (你)"; document.getElementById('blue-name').textContent="蓝方 (电脑)"; }
            else { document.getElementById('red-name').textContent="红方 (电脑)"; document.getElementById('blue-name').textContent="蓝方 (你)"; }
        }

        if(mode==='pve' && STATE.pvePlayer==='blue') { aiPlaceShips('red'); startPlacement('blue'); }
        else startPlacement('red');
    }

    function showRules() { document.getElementById('modal-rules').classList.remove('hidden'); }
    function closeRules(e) { document.getElementById('modal-rules').classList.add('hidden'); }

    function startPlacement(who) {
        STATE.phase='placement'; STATE.placing=who; STATE.isHorizontal=true; STATE.selectedShipId=null;
        document.getElementById('btn-rot').textContent="方向: 横向";
        els.btnConfirm.disabled=true; els.placeUI.classList.remove('hidden');
        
        const isRed = (who==='red');
        els.redWrapper.classList.toggle('visually-hidden', !isRed);
        els.blueWrapper.classList.toggle('visually-hidden', isRed);

        els.redBoard.classList.toggle('show-ships', isRed); els.blueBoard.classList.toggle('show-ships', !isRed);
        els.redWrapper.classList.toggle('active-turn', isRed); els.blueWrapper.classList.toggle('active-turn', !isRed);
        els.msg.textContent = `${isRed?'红方':'蓝方'}部署：请选中舰艇，再点击海域放置`;
        els.msg.style.color = isRed ? "var(--red-pen)" : "var(--blue-pen)";
        
        els.dock.classList.remove('red-theme', 'blue-theme');
        els.dock.classList.add(isRed ? 'red-theme' : 'blue-theme');

        renderDock();
    }

    function renderDock() {
        els.dock.innerHTML='';
        const ships = STATE.placing==='red'?STATE.redShips:STATE.blueShips;
        const placedIds = ships.map(s=>s.id);
        let allPlaced=true;

        CONFIG.ships.forEach((size, id) => {
            if(!placedIds.includes(id)) {
                allPlaced=false;
                const item = document.createElement('div');
                item.className = 'dock-ship in-dock';
                if(STATE.selectedShipId===id) item.classList.add('selected');
                
                for(let i=0; i<size; i++) {
                    const cell = document.createElement('div');
                    cell.className='dock-cell';
                    cell.appendChild(createShipShapeHTML(i, size, false));
                    item.appendChild(cell);
                }
                item.onclick = () => { STATE.selectedShipId=id; renderDock(); };
                els.dock.appendChild(item);
            }
        });
        els.btnConfirm.disabled = !allPlaced;
        if(allPlaced) els.msg.textContent="部署完成，请点击确认";
    }

    function handleCellClick(x, y, owner) {
        if(STATE.phase==='placement') {
            if(owner!==STATE.placing || STATE.selectedShipId===null) return;
            if(placeShipOnBoard(x, y, CONFIG.ships[STATE.selectedShipId], STATE.selectedShipId)) {
                STATE.selectedShipId=null; renderDock();
            }
        } else if(STATE.phase==='combat') {
            if(owner===STATE.turn) return;
            if(STATE.mode==='pve' && STATE.turn!==STATE.pvePlayer) return;
            fireShot(owner, x, y);
        }
    }

    function placeShipOnBoard(x, y, size, id) {
        const grid=STATE.placing==='red'?STATE.redGrid:STATE.blueGrid;
        const ships=STATE.placing==='red'?STATE.redShips:STATE.blueShips;
        const boardEl=STATE.placing==='red'?els.redBoard:els.blueBoard;

        if(STATE.isHorizontal && x+size>10) return false;
        if(!STATE.isHorizontal && y+size>10) return false;

        for(let i=0; i<size; i++) {
            let cx=STATE.isHorizontal?x+i:x, cy=STATE.isHorizontal?y:y+i;
            if(grid[cy][cx]!==0) return false;
        }

        const coords=[];
        for(let i=0; i<size; i++) {
            let cx=STATE.isHorizontal?x+i:x, cy=STATE.isHorizontal?y:y+i;
            grid[cy][cx]=1; coords.push({x:cx,y:cy});
            const cell = boardEl.querySelector(`.cell[data-x="${cx}"][data-y="${cy}"]`);
            cell.classList.add('ship');
            cell.appendChild(createShipShapeHTML(i, size, STATE.isHorizontal));
        }
        ships.push({id, size, coords, sunk:false});
        return true;
    }

    function toggleOrientation() {
        STATE.isHorizontal=!STATE.isHorizontal;
        document.getElementById('btn-rot').textContent=STATE.isHorizontal?"方向: 横向":"方向: 纵向";
    }
    function undoLastShip() {
        const ships=STATE.placing==='red'?STATE.redShips:STATE.blueShips;
        const grid=STATE.placing==='red'?STATE.redGrid:STATE.blueGrid;
        const boardEl=STATE.placing==='red'?els.redBoard:els.blueBoard;
        if(!ships.length) return;
        const last=ships.pop();
        last.coords.forEach(c => {
            grid[c.y][c.x]=0;
            const cell=boardEl.querySelector(`.cell[data-x="${c.x}"][data-y="${c.y}"]`);
            cell.classList.remove('ship'); cell.innerHTML='';
        });
        STATE.selectedShipId=null; renderDock();
    }
    function resetPlacement() {
        const ships=STATE.placing==='red'?STATE.redShips:STATE.blueShips;
        while(ships.length) undoLastShip();
    }
    function randomPlacement() { resetPlacement(); aiPlaceShips(STATE.placing); renderDock(); }

    function confirmPlacement() {
        if(STATE.placing==='red') {
            if(STATE.mode==='pve') {
                if(!STATE.blueShips.length) aiPlaceShips('blue');
                startCombat();
            } else showTransition('blue_place');
        } else showTransition('combat_start');
    }

    function aiPlaceShips(color) {
        const grid=color==='red'?STATE.redGrid:STATE.blueGrid;
        const ships=color==='red'?STATE.redShips:STATE.blueShips;
        const boardEl=color==='red'?els.redBoard:els.blueBoard;
        
        CONFIG.ships.forEach((size, id) => {
            let placed=false;
            while(!placed) {
                const isH=Math.random()>0.5;
                const x=Math.floor(Math.random()*10), y=Math.floor(Math.random()*10);
                let valid=true;
                if((isH && x+size>10) || (!isH && y+size>10)) valid=false;
                else { for(let i=0; i<size; i++) if(grid[isH?y:y+i][isH?x+i:x]!==0) valid=false; }
                
                if(valid) {
                    const coords=[];
                    for(let i=0; i<size; i++) {
                        let cx=isH?x+i:x, cy=isH?y:y+i;
                        grid[cy][cx]=1; coords.push({x:cx,y:cy});
                        const cell=boardEl.querySelector(`.cell[data-x="${cx}"][data-y="${cy}"]`);
                        cell.classList.add('ship');
                        cell.appendChild(createShipShapeHTML(i, size, isH));
                    }
                    ships.push({id, size, coords, sunk:false});
                    placed=true;
                }
            }
        });
    }

    function showTransition(type) {
        els.modalTrans.classList.remove('hidden');
        const txt=document.getElementById('transition-msg');
        if(type==='blue_place') {
            txt.innerHTML="红方部署完毕。<br>请红方回避，交由蓝方部署。";
            STATE.nextTransitionAction=()=>startPlacement('blue');
        } else if(type==='combat_start') {
            txt.innerHTML="部署完毕，战斗警报！<br>红方准备开火。";
            STATE.nextTransitionAction=startCombat;
        } else if(type.startsWith('switch')) {
            const next=type==='switch_red'?'红方':'蓝方';
            txt.innerHTML=`未命中。<br>攻守交换，${next}准备。`;
            STATE.nextTransitionAction=()=>switchTurn(type==='switch_red'?'red':'blue');
        }
    }
    function endTransition() { els.modalTrans.classList.add('hidden'); if(STATE.nextTransitionAction) STATE.nextTransitionAction(); }

    function startCombat() {
        STATE.phase='combat'; els.placeUI.classList.add('hidden'); els.dock.style.display='none';
        
        els.redWrapper.classList.remove('visually-hidden');
        els.blueWrapper.classList.remove('visually-hidden');
        
        switchTurn('red');
        if(STATE.mode==='pve' && STATE.pvePlayer==='blue') setTimeout(processAiTurn, 1000);
    }
    function switchTurn(who) {
        STATE.turn=who;
        els.redBoard.classList.remove('show-ships'); els.blueBoard.classList.remove('show-ships');
        els.redWrapper.classList.remove('active-turn'); els.blueWrapper.classList.remove('active-turn');
        const isRed=(who==='red');
        if(isRed) { els.redBoard.classList.add('show-ships'); els.redWrapper.classList.add('active-turn'); }
        else { els.blueBoard.classList.add('show-ships'); els.blueWrapper.classList.add('active-turn'); }
        
        if(STATE.mode === 'pve') {
            if(who === STATE.pvePlayer) {
                 els.msg.textContent = "轮到你了！点击敌方海域开火";
            } else {
                 els.msg.textContent = "敌方正在瞄准...";
            }
        } else {
            els.msg.textContent=`${isRed?'红方':'蓝方'}回合：点击敌方海域开火`;
        }
        els.msg.style.color=isRed?"var(--red-pen)":"var(--blue-pen)";
        
        if(STATE.mode==='pve') {
            if(STATE.pvePlayer==='red') { els.redBoard.classList.add('show-ships'); els.blueBoard.classList.remove('show-ships'); }
            else { els.blueBoard.classList.add('show-ships'); els.redBoard.classList.remove('show-ships'); }
        }
    }

    function fireShot(targetOwner, x, y) {
        const grid=targetOwner==='red'?STATE.redGrid:STATE.blueGrid;
        const boardEl=targetOwner==='red'?els.redBoard:els.blueBoard;
        if(grid[y][x]>1) return false;

        const cell=boardEl.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
        const boom=document.createElement('div'); boom.className='boom'; cell.appendChild(boom);
        setTimeout(()=>boom.remove(),400);

        if(grid[y][x]===1) {
            grid[y][x]=3; cell.classList.add('hit');
            
            const isPveAi = (STATE.mode==='pve' && STATE.turn!==STATE.pvePlayer);
            if (isPveAi) {
                els.msg.textContent = "敌方命中！它将继续开火！";
            } else {
                els.msg.textContent = "命中！继续开火！";
            }

            const sunk=checkSunk(targetOwner); checkWin(targetOwner);
            if(STATE.phase==='gameover') return;
            
            if(isPveAi) {
                rebuildAiStack(targetOwner);
                setTimeout(processAiTurn, 1000);
            }
            return true;
        } else {
            grid[y][x]=2; cell.classList.add('miss');
            
            const isPveAi = (STATE.mode === 'pve' && STATE.turn !== STATE.pvePlayer);
            if (isPveAi) els.msg.textContent = "敌方未命中..."; 
            else els.msg.textContent = "未命中...";

            if(STATE.mode==='pvp') {
                setTimeout(()=>showTransition(STATE.turn==='red'?'switch_blue':'switch_red'), 800);
            } else {
                const next=STATE.turn==='red'?'blue':'red';
                if(next === STATE.pvePlayer) {
                    setTimeout(() => {
                        switchTurn(next);
                        els.msg.textContent = "轮到你了！进行反击！";
                    }, 1000);
                } else {
                    switchTurn(next);
                    if(next!==STATE.pvePlayer) {
                        rebuildAiStack(targetOwner==='red'?'blue':'red'); 
                        setTimeout(processAiTurn, 1000);
                    }
                }
            }
            return false;
        }
    }

    function checkSunk(owner) {
        const ships=owner==='red'?STATE.redShips:STATE.blueShips;
        const grid=owner==='red'?STATE.redGrid:STATE.blueGrid;
        const boardEl=owner==='red'?els.redBoard:els.blueBoard;
        let anySunk=false;
        let justSunk=false;

        ships.forEach(ship => {
            if(!ship.sunk) {
                if(ship.coords.every(c=>grid[c.y][c.x]===3)) {
                    ship.sunk=true; anySunk=true; justSunk=true;
                    
                    ship.coords.forEach(c=>{
                        const cell = boardEl.querySelector(`.cell[data-x="${c.x}"][data-y="${c.y}"]`);
                        cell.classList.add('sunk');
                        const mark = document.createElement('div');
                        mark.className = 'sunk-mark';
                        cell.appendChild(mark);
                    });
                    updateScore();
                }
            }
        });
        
        if(justSunk) {
            els.msg.textContent = "敌舰沉没！获得连击奖励，请继续轰炸！";
        }
        
        return anySunk;
    }
    function updateScore() {
        const r=STATE.redShips.filter(s=>!s.sunk).length;
        const b=STATE.blueShips.filter(s=>!s.sunk).length;
        document.getElementById('red-score').textContent=`战舰: ${r}`;
        document.getElementById('blue-score').textContent=`战舰: ${b}`;
    }
    function checkWin(loser) {
        const ships=loser==='red'?STATE.redShips:STATE.blueShips;
        if(ships.every(s=>s.sunk)) {
            STATE.phase='gameover'; els.modalOver.classList.remove('hidden');
            const winner=loser==='red'?'蓝方':'红方';
            document.getElementById('winner-msg').textContent=`${winner} 取得最终胜利！`;
            document.getElementById('winner-title').style.color=loser==='red'?'var(--blue-pen)':'var(--red-pen)';
        }
    }

    /* --- AI 核心逻辑 --- */
    
    // 获取对手剩余最小船只尺寸
    function getMinFloatingShipSize(owner) {
        const ships = owner === 'red' ? STATE.redShips : STATE.blueShips;
        const floating = ships.filter(s => !s.sunk);
        if (floating.length === 0) return 2; // 防御性代码
        return Math.min(...floating.map(s => s.size));
    }

    // 检查某个方向上是否有足够的空间容纳最小船只
    // x,y: 候选攻击点的坐标
    // grid: 棋盘数据
    // minSize: 最小船尺寸
    // axis: 'H' (横向检查) 或 'V' (纵向检查)
    function hasEnoughSpace(x, y, grid, minSize, axis) {
        let count = 0;
        // 注意：这里的空间包含“未探测(0)”和“命中(3)”，因为船可能藏在已命中的点旁边。
        // “脱靶(2)”是墙壁。
        
        if (axis === 'H') {
            // 向左扫描
            for (let i = x; i >= 0; i--) {
                if (grid[y][i] === 2) break; // 遇到脱靶点停止
                count++;
            }
            // 向右扫描 (从x+1开始避免重复计数x点)
            for (let i = x + 1; i < 10; i++) {
                if (grid[y][i] === 2) break;
                count++;
            }
        } else { // Vertical
             // 向上扫描
             for (let i = y; i >= 0; i--) {
                if (grid[i][x] === 2) break;
                count++;
            }
            // 向下扫描
            for (let i = y + 1; i < 10; i++) {
                if (grid[i][x] === 2) break;
                count++;
            }
        }
        return count >= minSize;
    }

    function rebuildAiStack(targetOwner) {
        const grid = targetOwner==='red'?STATE.redGrid:STATE.blueGrid;
        const ships = targetOwner==='red'?STATE.redShips:STATE.blueShips;
        STATE.aiStack = [];

        // 1. 获取最小存活船只尺寸
        const minSize = getMinFloatingShipSize(targetOwner);

        // 2. 找出所有“已命中”但“不属于已沉没船只”的点
        const activeHits = [];
        for(let y=0; y<10; y++){
            for(let x=0; x<10; x++){
                if(grid[y][x] === 3) {
                    let isSunkShipPart = false;
                    for(let s of ships) {
                        if(s.sunk && s.coords.some(c => c.x===x && c.y===y)) {
                            isSunkShipPart = true; break;
                        }
                    }
                    if(!isSunkShipPart) activeHits.push({x, y});
                }
            }
        }

        if(activeHits.length === 0) return; 

        // 3. 策略：连线检查与空间过滤
        let foundLine = false;

        // 检查是否有两点共线
        for(let i=0; i<activeHits.length; i++) {
            for(let j=i+1; j<activeHits.length; j++) {
                const p1 = activeHits[i];
                const p2 = activeHits[j];
                
                // 纵向共线
                if(p1.x === p2.x && Math.abs(p1.y - p2.y) === 1) {
                    foundLine = true;
                    // 尝试添加上下两端，必须传入 'V' 轴做空间检查
                    tryAddValidNeighbor(p1.x, p1.y - 1, grid, minSize, 'V');
                    tryAddValidNeighbor(p2.x, p2.y + 1, grid, minSize, 'V');
                    tryAddValidNeighbor(p1.x, p1.y + 1, grid, minSize, 'V');
                    tryAddValidNeighbor(p2.x, p2.y - 1, grid, minSize, 'V');
                }
                // 横向共线
                else if(p1.y === p2.y && Math.abs(p1.x - p2.x) === 1) {
                    foundLine = true;
                    tryAddValidNeighbor(p1.x - 1, p1.y, grid, minSize, 'H');
                    tryAddValidNeighbor(p2.x + 1, p2.y, grid, minSize, 'H');
                    tryAddValidNeighbor(p1.x + 1, p1.y, grid, minSize, 'H');
                    tryAddValidNeighbor(p2.x - 1, p2.y, grid, minSize, 'H');
                }
            }
        }

        // 如果没有发现连线，对孤立点进行十字搜索，但加上空间校验
        if(!foundLine) {
            activeHits.forEach(p => {
                // 上下尝试：用 'V' 轴校验
                tryAddValidNeighbor(p.x, p.y-1, grid, minSize, 'V');
                tryAddValidNeighbor(p.x, p.y+1, grid, minSize, 'V');
                // 左右尝试：用 'H' 轴校验
                tryAddValidNeighbor(p.x-1, p.y, grid, minSize, 'H');
                tryAddValidNeighbor(p.x+1, p.y, grid, minSize, 'H');
            });
        }
    }

    function tryAddValidNeighbor(x, y, grid, minSize, axis) {
        if(x>=0 && x<10 && y>=0 && y<10) {
            // 只有 未知(0) 的格子才值得炸
            if(grid[y][x] <= 1) {
                // 关键修复：检查该点所在轴线是否有足够空间容纳最小船只
                if(hasEnoughSpace(x, y, grid, minSize, axis)) {
                    // 避免重复
                    if(!STATE.aiStack.some(t => t.x===x && t.y===y)) {
                        STATE.aiStack.push({x, y});
                    }
                }
            }
        }
    }

    function processAiTurn() {
        if(STATE.phase!=='combat') return;
        const target=STATE.pvePlayer, grid=target==='red'?STATE.redGrid:STATE.blueGrid;
        
        let tx, ty;

        // 1. 优先尝试 Stack 中的目标
        while(STATE.aiStack.length > 0) {
            const t = STATE.aiStack.pop();
            // 再次检查是否合法（可能已经被之前的连击炸过了）
            if(grid[t.y][t.x] <= 1) {
                tx = t.x; ty = t.y;
                break;
            }
        }

        // 2. 随机模式 (Hunt Mode)
        if(tx === undefined) {
            let candidates = [];
            // 优化：优先攻击棋盘黑白格位置 (Parity Hunting)，因为最小船是2格
            for(let y=0; y<10; y++) {
                for(let x=0; x<10; x++) {
                    if(grid[y][x] <= 1 && (x+y)%2 === 0) {
                        candidates.push({x,y});
                    }
                }
            }
            if(candidates.length === 0) {
                for(let y=0; y<10; y++) for(let x=0; x<10; x++) if(grid[y][x] <= 1) candidates.push({x,y});
            }

            if(candidates.length > 0) {
                const rand = candidates[Math.floor(Math.random() * candidates.length)];
                tx = rand.x; ty = rand.y;
            }
        }
        
        if(tx!==undefined) {
            fireShot(target, tx, ty);
        }
    }
</script>
</body>
</html>