<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç»å¢ƒéª°å­ (by Arthur)</title>
    <style>
        /* --- æ ·å¼å®Œå…¨ä¿æŒ v7.0 ä¸å˜ --- */
        :root {
            --bg-color: #121212;
            --card-bg: #252526;
            --text-color: #e0e0e0;
            --accent: #00e5ff;
            --accent-glow: rgba(0, 229, 255, 0.4);
            --danger: #ff5252;
            --armor: #69f0ae;
            --energy: #ffd740;
            --modifier: #b388ff;
            --void: #9c27b0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, Helvetica, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh; 
            overflow: hidden;
            user-select: none;
        }

        .header-bar {
            flex: 0 0 auto;
            background: rgba(20, 20, 20, 0.95);
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
            z-index: 10;
        }
        .game-title { font-weight: 800; color: #fff; font-size: 1.1em; letter-spacing: 0.5px; }
        .game-title span { color: var(--accent); font-size: 0.8em; font-weight: normal; margin-left: 5px; }
        .btn-rules { background: transparent; border: 1px solid #555; color: #aaa; padding: 4px 10px; border-radius: 15px; cursor: pointer; font-size: 0.75em; }

        .hud {
            flex: 0 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #2a2a2a;
            font-size: 0.9em;
            gap: 5px;
            z-index: 9;
        }
        .stat-item { display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .stat-label { font-size: 0.7em; color: #888; margin-bottom: 3px; display: flex; align-items: center; gap: 4px; }
        .stat-val { font-weight: 700; font-size: 1.1em; }

        #game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden; 
            padding: 15px;
            padding-bottom: 0; 
            max-width: 500px;
            margin: 0 auto;
            width: 100%;
            box-sizing: border-box;
        }

        .fixed-zone { flex: 0 0 auto; margin-bottom: 10px; }

        .scroll-zone {
            flex: 1;
            overflow-y: auto;
            padding-bottom: 10px;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none; 
        }
        .scroll-zone::-webkit-scrollbar { display: none; }

        .modifier-bar {
            background: rgba(179, 136, 255, 0.1);
            border: 1px solid var(--modifier);
            color: var(--modifier);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.8em;
            text-align: center;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            animation: fadeIn 0.5s;
        }

        .enemy-area {
            display: flex;
            align-items: center;
            padding: 15px;
            background: linear-gradient(145deg, #2a2a2d, #1f1f22);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            border-radius: 12px;
            border: 1px solid #333;
            min-height: 80px;
        }
        .enemy-avatar { font-size: 3.5em; margin-right: 15px; animation: float 3s ease-in-out infinite; filter: drop-shadow(0 5px 5px rgba(0,0,0,0.5)); }
        .enemy-info { flex: 1; }
        .enemy-hp-bar { height: 8px; background: #111; margin-top: 8px; border-radius: 4px; overflow: hidden; }
        .enemy-hp-fill { height: 100%; background: linear-gradient(90deg, #ff5252, #d50000); width: 100%; transition: width 0.3s ease-out; }
        
        .enemy-meta { margin-top: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
        .enemy-intent { color: #ff8a80; display: flex; align-items: center; gap: 4px; font-weight: 500; }
        .turn-counter { color: #888; background: #111; padding: 2px 8px; border-radius: 10px; border: 1px solid #333; font-size: 0.9em; }
        .turn-counter.danger { color: var(--void); border-color: var(--void); animation: pulse 1s infinite; }

        .board-area { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; padding: 2px; }

        .card {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            transition: all 0.2s;
            cursor: pointer;
            border: 1px solid #333;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            position: relative;
        }
        .card:hover { transform: translateY(-2px); border-color: #555; }
        .card.active-target { border-color: var(--accent); box-shadow: 0 0 10px var(--accent-glow); background: #2d2d30; }
        
        .card-header { font-size: 0.85em; font-weight: 700; color: #fff; display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;}
        .card-lvl { font-size: 0.75em; color: var(--energy); background: rgba(255, 215, 64, 0.15); padding: 1px 5px; border-radius: 4px; }
        .card-desc { font-size: 0.7em; color: #999; margin-bottom: 8px; min-height: 2.4em; line-height: 1.3;}
        
        .card-slots {
            background: rgba(0,0,0,0.4);
            border-radius: 6px;
            padding: 5px;
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-content: flex-start;
            min-height: 42px;
            border: 1px dashed #444;
        }
        .card-slots:empty::after { content: "ç‚¹å‡»ç½®å…¥"; display: block; width: 100%; text-align: center; margin-top: 10px; font-size: 0.7em; color: #555; }

        .die {
            width: 46px; height: 46px;
            background: linear-gradient(145deg, #fff, #dcdcdc);
            border-radius: 8px;
            box-shadow: 2px 4px 6px rgba(0,0,0,0.4), inset 1px 1px 0px #fff;
            position: relative;
            cursor: pointer;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 6px;
            box-sizing: border-box;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .card-slots .die { width: 30px; height: 30px; padding: 3px; pointer-events: none; border-radius: 5px; box-shadow: 1px 2px 3px rgba(0,0,0,0.5); }
        .card-slots .die .dot { width: 5px; height: 5px; }

        .dot { width: 8px; height: 8px; background: radial-gradient(circle at 30% 30%, #444, #000); border-radius: 50%; align-self: center; justify-self: center; box-shadow: 0 1px 0 rgba(255,255,255,0.5); }
        
        .die[data-val="1"] > :nth-child(1) { grid-area: 2 / 2; background: radial-gradient(circle at 30% 30%, #ff5252, #b71c1c); }
        .die[data-val="2"] > :nth-child(1) { grid-area: 1 / 1; } .die[data-val="2"] > :nth-child(2) { grid-area: 3 / 3; }
        .die[data-val="3"] > :nth-child(1) { grid-area: 1 / 1; } .die[data-val="3"] > :nth-child(2) { grid-area: 2 / 2; } .die[data-val="3"] > :nth-child(3) { grid-area: 3 / 3; }
        .die[data-val="4"] > :nth-child(1) { grid-area: 1 / 1; } .die[data-val="4"] > :nth-child(2) { grid-area: 1 / 3; } .die[data-val="4"] > :nth-child(3) { grid-area: 3 / 1; } .die[data-val="4"] > :nth-child(4) { grid-area: 3 / 3; }
        .die[data-val="5"] > :nth-child(1) { grid-area: 1 / 1; } .die[data-val="5"] > :nth-child(2) { grid-area: 1 / 3; } .die[data-val="5"] > :nth-child(3) { grid-area: 2 / 2; } .die[data-val="5"] > :nth-child(4) { grid-area: 3 / 1; } .die[data-val="5"] > :nth-child(5) { grid-area: 3 / 3; }
        .die[data-val="6"] > :nth-child(1) { grid-area: 1 / 1; } .die[data-val="6"] > :nth-child(2) { grid-area: 1 / 3; } .die[data-val="6"] > :nth-child(3) { grid-area: 2 / 1; } .die[data-val="6"] > :nth-child(4) { grid-area: 2 / 3; } .die[data-val="6"] > :nth-child(5) { grid-area: 3 / 1; } .die[data-val="6"] > :nth-child(6) { grid-area: 3 / 3; }

        .die.selected { transform: translateY(-8px) scale(1.1); box-shadow: 0 0 15px var(--accent-glow), 0 0 5px var(--accent); border: 1px solid var(--accent); z-index: 5; }

        .bonus-text { position: absolute; top: -8px; right: -6px; font-size: 0.7em; font-weight: 900; color: var(--energy); text-shadow: 1px 1px 0 #000; animation: pop 0.3s; z-index: 6; pointer-events: none; }

        .control-area { flex: 0 0 auto; background: #1e1e1e; padding: 15px 10px; border-top: 1px solid #333; box-shadow: 0 -4px 10px rgba(0,0,0,0.2); z-index: 10; }
        .hand-area { display: flex; justify-content: center; gap: 12px; min-height: 55px; margin-bottom: 12px; }
        .btn-group { display: flex; gap: 10px; }
        .btn { flex: 1; padding: 14px; border: none; border-radius: 8px; font-weight: 700; cursor: pointer; color: #fff; font-size: 0.95em; display: flex; justify-content: center; align-items: center; gap: 6px; letter-spacing: 1px; }
        .btn-reroll { background: #333; color: var(--energy); border: 1px solid #444; }
        .btn-reroll:active { transform: translateY(2px); }
        .btn-reroll:disabled { opacity: 0.4; }
        .btn-end { background: linear-gradient(135deg, #d32f2f, #b71c1c); box-shadow: 0 3px 0 #7f0000; }
        .btn-end:active { transform: translateY(3px); box-shadow: none; }

        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.92); z-index: 100; display: none; flex-direction: column; justify-content: center; align-items: center; backdrop-filter: blur(4px); }
        .modal.active { display: flex; animation: fadeIn 0.3s; }
        .modal-box { background: #222; padding: 25px; border-radius: 12px; max-width: 85%; width: 320px; border: 1px solid #444; color: #eee; box-shadow: 0 10px 30px rgba(0,0,0,0.6); }
        .reward-option { background: #2e2e31; padding: 15px; margin: 10px 0; border: 1px solid #444; cursor: pointer; border-radius: 8px; text-align: center; transition: 0.2s; }
        .reward-option:hover { border-color: var(--accent); background: #38383b; }

        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }
        @keyframes pop { 0% { transform: scale(0); } 80% { transform: scale(1.2); } 100% { transform: scale(1); } }
        @keyframes shake { 0% { transform: translateX(0); } 20% { transform: translateX(-5px); } 40% { transform: translateX(5px); } 60% { transform: translateX(-5px); } 80% { transform: translateX(5px); } 100% { transform: translateX(0); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        .shake { animation: shake 0.4s; }
        .fade-in { animation: pop 0.3s ease-out backwards; }
    </style>
</head>
<body>

<div class="header-bar">
    <div class="game-title">ç»å¢ƒéª°å­ <span>by Arthur</span></div>
    <button class="btn-rules" onclick="toggleRules()">ğŸ“œ è§„åˆ™</button>
</div>

<div class="hud">
    <div class="stat-item">
        <div class="stat-label">â¤ï¸ ç”Ÿå‘½</div>
        <div class="stat-val" style="color:var(--danger)"><span id="hp-val">30</span>/<span id="max-hp-val">30</span></div>
    </div>
    <div class="stat-item">
        <div class="stat-label">ğŸ›¡ï¸ æŠ¤ç”²</div>
        <div class="stat-val" style="color:var(--armor)" id="armor-val">0</div>
    </div>
    <div class="stat-item">
        <div class="stat-label">ğŸš© å±‚æ•°</div>
        <div class="stat-val" style="color:var(--accent)" id="floor-val">1</div>
    </div>
</div>

<div id="game-container">
    <div class="fixed-zone">
        <div id="modifier-area" class="modifier-bar" style="display:none;"></div>

        <div class="enemy-area" id="enemy-area">
            <div class="enemy-avatar" id="enemy-avatar">ğŸ‘¾</div>
            <div class="enemy-info">
                <div style="display:flex; justify-content:space-between; align-items:flex-end;">
                    <strong id="enemy-name" style="font-size:1.1em;">å²è±å§†</strong>
                    <span style="font-size:0.9em; color:#888;" id="enemy-hp-text">20/20</span>
                </div>
                <div class="enemy-hp-bar"><div class="enemy-hp-fill" id="enemy-hp-fill" style="width: 100%;"></div></div>
                
                <div class="enemy-meta">
                    <div class="enemy-intent" id="enemy-intent"></div>
                    <div class="turn-counter" id="turn-counter"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="scroll-zone">
        <div class="board-area" id="board-area"></div>
        <div id="log-area" style="text-align:center; font-size:0.75em; color:#666; height:20px; margin-top:10px;"></div>
    </div>
</div>

<div class="control-area">
    <div class="hand-area" id="hand-area"></div>
    <div class="btn-group">
        <button class="btn btn-reroll" id="btn-reroll" onclick="game.reroll()">
            â™»ï¸ é‡æ· <span id="reroll-count" style="background:#444; padding:0 6px; border-radius:4px; font-size:0.8em;">2</span>
        </button>
        <button class="btn btn-end" onclick="game.endTurn()">ç»“æŸå›åˆ</button>
    </div>
</div>

<div class="modal" id="rules-modal">
    <div class="modal-box">
        <h2 style="color:var(--accent); margin-top:0; text-align:center;">å†’é™©æŒ‡å—</h2>
        <div style="font-size: 0.9em; line-height: 1.6; color:#ccc;">
            <p>1. <strong>ç©æ³•</strong>ï¼šæ·éª°å­ï¼Œå¡«è£…å¤‡ï¼Œå‡»è´¥å…±8å±‚å¼ºæ•Œã€‚</p>
            <p>2. <strong>å›åˆé™åˆ¶</strong>ï¼šæ™®é€šå±‚<strong>6-7å›åˆ</strong>ï¼Œé¦–é¢†å±‚<strong>10å›åˆ</strong>ã€‚è¶…æ—¶å°†å—åˆ°è™šç©ºçœŸå®ä¼¤å®³ã€‚</p>
            <p>3. <strong>å‡çº§</strong>ï¼šè·å¾—é‡å¤è£…å¤‡å¯æå‡ç­‰çº§ã€‚</p>
            <p>4. <strong>ç¯å¢ƒ</strong>ï¼šæ³¨æ„æ¯å±‚çš„ç¯å¢ƒå¼‚å˜ã€‚</p>
        </div>
        <button class="btn btn-reroll" style="margin-top:20px; width:100%; color:#fff;" onclick="toggleRules()">å…³é—­</button>
    </div>
</div>

<div class="modal" id="reward-modal">
    <div class="modal-box">
        <h2 id="reward-title" style="text-align:center; color:#fff;">èƒœåˆ©!</h2>
        <p id="reward-msg" style="text-align:center; color:#888; margin-bottom:15px;">é€‰æ‹©ä½ çš„æˆ˜åˆ©å“</p>
        <div id="reward-options"></div>
    </div>
</div>

<script>
const MODIFIERS = [
    { id: 'normal', name: 'å¹³é™', desc: 'æ— ç‰¹æ®Šæ•ˆæœ', color: '#888' },
    { id: 'fog', name: 'è¿·é›¾', desc: 'âš ï¸ æ”»å‡»æ•°å€¼æœ‰æ³¢åŠ¨ (-2 ~ +3)', color: '#ccc' },
    { id: 'rage', name: 'ç‹‚æš´', desc: 'ğŸ”¥ æ•Œæˆ‘åŒæ–¹é€ æˆä¼¤å®³ +2', color: '#ff5252' },
    { id: 'regen', name: 'ç”Ÿæœº', desc: 'ğŸŒ¿ ç©å®¶æ¯å›åˆå›å¤ 2 HP', color: '#69f0ae' },
    { id: 'curse', name: 'å„è¿', desc: 'ğŸ“‰ éª°å­æœ€å¤§ç‚¹æ•°ä¸º 5', color: '#b388ff' },
    { id: 'bless', name: 'å¹¸è¿', desc: 'âœ¨ éª°å­æœ€å°ç‚¹æ•°ä¸º 2', color: '#ffd740' }
];

const ITEMS_DB = [
    { id: 'sword', icon: 'ğŸ—¡ï¸', name: 'é”ˆé“å‰‘', desc: 'é€ æˆ [ç‚¹æ•°+ç­‰çº§] ä¼¤å®³', condition: (v)=>true, 
      effect: (v, g, lvl) => { 
          let bonus = (g.currentMod.id === 'rage') ? 2 : 0;
          let val = v + lvl + bonus; 
          g.damageEnemy(val); 
          return `-${val}`; 
      } 
    },
    { id: 'shield', icon: 'ğŸ›¡ï¸', name: 'åœ†ç›¾', desc: 'è·å¾— [ç‚¹æ•°+ç­‰çº§] æŠ¤ç”²', condition: (v)=>true, 
      effect: (v, g, lvl) => { 
          let val = v + lvl; 
          g.addArmor(val); 
          return `+${val}`; 
      } 
    },
    { id: 'dagger', icon: 'ğŸ”ª', name: 'åŒ•é¦–', desc: 'æœ€å¤§3ç‚¹: [2å€+ç­‰çº§] ä¼¤å®³', condition: (v) => v <= 3, 
      effect: (v, g, lvl) => { 
          let bonus = (g.currentMod.id === 'rage') ? 2 : 0;
          let val = (v * 2) + lvl + bonus; 
          g.damageEnemy(val); 
          return "CRIT!"; 
      } 
    },
    { id: 'wand', icon: 'ğŸ”®', name: 'æ³•æ–', desc: 'å¶æ•°: [6+ç­‰çº§] ä¼¤å®³', condition: (v) => v % 2 === 0, 
      effect: (v, g, lvl) => { 
          let bonus = (g.currentMod.id === 'rage') ? 2 : 0;
          let val = 6 + lvl + bonus; 
          g.damageEnemy(val); 
          return "ZAP!"; 
      } 
    },
    { id: 'hammer', icon: 'ğŸ”¨', name: 'é‡é”¤', desc: 'ç‚¹æ•°6: [10+ç­‰çº§] ä¼¤å®³', condition: (v) => v === 6, 
      effect: (v, g, lvl) => { 
          let bonus = (g.currentMod.id === 'rage') ? 2 : 0;
          let val = 10 + lvl + bonus; 
          g.damageEnemy(val); 
          return "SMASH!"; 
      } 
    },
    { id: 'heal', icon: 'ğŸ§ª', name: 'è¯ç“¶', desc: 'æœ€å°å€¼4: å›å¤ [3+ç­‰çº§] HP', condition: (v) => v >= 4, 
      effect: (v, g, lvl) => { 
          let val = 3 + lvl; 
          g.healPlayer(val); 
          return `+${val}`; 
      } 
    },
    { id: 'battery', icon: 'ğŸ”‹', name: 'å……èƒ½å™¨', desc: 'è·å¾— [ç‚¹æ•°] æ¬¡é‡æ·', condition: (v) => true, 
      effect: (v, g, lvl) => { g.addReroll(v); return `+${v} â™»ï¸`; } 
    }
];

// --- å¹³è¡¡æ€§é‡æ„ï¼š8å±‚æŒ‘æˆ˜ ---
// éš¾åº¦æ›²çº¿ï¼šF1-F3 (æ–°æ‰‹/6å›åˆ), F4-F6 (è¿›é˜¶/7å›åˆ), F7-F8 (å™©æ¢¦/10å›åˆ)
const ENEMIES_DB = [
    { name: 'å²è±å§†', hp: 25, dmg: 5, emoji: 'ğŸŸ¢', type: 'early' },
    { name: 'å˜å¼‚å·¨é¼ ', hp: 35, dmg: 6, emoji: 'ğŸ€', type: 'early' }, // New
    { name: 'è…åŒ–æ ‘äºº', hp: 50, dmg: 7, emoji: 'ğŸŒ³', type: 'early' },
    { name: 'æš—å½±åˆºå®¢', hp: 65, dmg: 9, emoji: 'ğŸ—¡ï¸', type: 'mid' },
    { name: 'å²©çŸ³å·¨äºº', hp: 80, dmg: 10, emoji: 'ğŸ—¿', type: 'mid' }, // New
    { name: 'æ­»çµå·«å¦–', hp: 100, dmg: 12, emoji: 'ğŸ’€', type: 'mid' },
    { name: 'æš—é»‘éª‘å£«', hp: 130, dmg: 14, emoji: 'ğŸ‘¹', type: 'late' }, // New
    { name: 'æ·±æ¸Šé­”é¾™', hp: 160, dmg: 16, emoji: 'ğŸ‰', type: 'late' }
];

function getDieHTML(value) {
    let dots = '';
    for(let i=0; i<value; i++) dots += '<div class="dot"></div>';
    return `<div class="die fade-in" data-val="${value}">${dots}</div>`;
}

class Game {
    constructor() {
        this.player = { hp: 30, maxHp: 30, armor: 0, rerolls: 2, diceCount: 3 };
        this.inventory = []; 
        this.handDice = []; 
        this.selectedHandIndex = null;
        this.floor = 1;
        this.currentMod = MODIFIERS[0];
        this.turnCount = 1;
        this.maxTurns = 8;
        
        this.addItem('sword');
        this.addItem('shield');
        
        this.initFloor();
    }

    initFloor() {
        // ç›´æ¥é€šå…³æ£€æŸ¥
        if (this.floor > ENEMIES_DB.length) {
            return; // é€»è¾‘ç”±winBattleå¤„ç†
        }

        if (this.floor === 1) this.currentMod = MODIFIERS[0];
        else this.currentMod = MODIFIERS[Math.floor(Math.random() * MODIFIERS.length)];

        const eData = ENEMIES_DB[this.floor - 1];
        this.enemy = { ...eData, maxHp: eData.hp, currentHp: eData.hp };
        
        // ç´§å‡‘çš„å›åˆé™åˆ¶ç­–ç•¥
        if (eData.type === 'early') this.maxTurns = 6;
        else if (eData.type === 'mid') this.maxTurns = 7;
        else this.maxTurns = 10;

        this.turnCount = 1;
        
        this.startTurn();
    }

    startTurn() {
        this.turnState = 'player';
        this.player.armor = 0;
        this.player.rerolls = 2; 
        this.handDice = [];
        this.inventory.forEach(item => item.storedDice = []); 
        
        if (this.currentMod.id === 'regen') {
            this.healPlayer(2);
        }

        if (this.turnCount > this.maxTurns) {
            const erosionDmg = this.turnCount - this.maxTurns;
            this.player.hp -= erosionDmg;
            this.shake('game-container');
            this.log(`â›” è™šç©ºä¾µèš€ï¼šå—åˆ° ${erosionDmg} ç‚¹çœŸå®ä¼¤å®³ï¼`);
            if (this.player.hp <= 0) {
                this.player.hp = 0;
                this.updateUI();
                setTimeout(()=>this.showRewardModal("è¶…æ—¶æˆ˜è´¥", "ä½ åœ¨è™šç©ºä¸­æ¶ˆäº¡äº†...", true), 500);
                return;
            }
        }

        for(let i=0; i<this.player.diceCount; i++) {
            this.handDice.push({ value: this.rollD6(), id: Math.random() });
        }
        
        this.selectedHandIndex = null;
        if (this.turnCount <= this.maxTurns) {
            this.log(`ç¬¬ ${this.floor} å±‚ - ${this.currentMod.name}`);
        }
        this.updateUI();
    }

    rollD6() {
        let val = Math.floor(Math.random() * 6) + 1;
        if (this.currentMod.id === 'curse') val = Math.min(val, 5);
        if (this.currentMod.id === 'bless') val = Math.max(val, 2);
        return val;
    }

    selectHandDie(index) {
        if (this.turnState !== 'player') return;
        this.selectedHandIndex = (this.selectedHandIndex === index) ? null : index;
        this.updateUI();
    }

    useItem(itemIndex) {
        if (this.turnState !== 'player' || this.selectedHandIndex === null) return;
        
        const die = this.handDice[this.selectedHandIndex];
        const item = this.inventory[itemIndex];
        const dbItem = ITEMS_DB.find(i => i.id === item.id);

        if (!dbItem.condition(die.value)) {
            this.log("âŒ ä¸æ»¡è¶³ç‚¹æ•°æ¡ä»¶");
            this.shake('board-area');
            return;
        }

        const bonusText = dbItem.effect(die.value, this, item.level);
        
        item.storedDice.push({ value: die.value, bonus: bonusText });
        this.handDice.splice(this.selectedHandIndex, 1);
        this.selectedHandIndex = null;

        this.checkWin();
        this.updateUI();
    }

    reroll() {
        if (this.player.rerolls > 0 && this.handDice.length > 0) {
            this.player.rerolls--;
            this.handDice.forEach(d => d.value = this.rollD6());
            this.log("é‡æ·å®Œæˆ");
            this.selectedHandIndex = null;
            this.updateUI();
        }
    }

    damageEnemy(amt) {
        this.enemy.currentHp = Math.max(0, this.enemy.currentHp - amt);
        this.shake('enemy-avatar');
    }

    addArmor(amt) { this.player.armor += amt; }
    healPlayer(amt) { this.player.hp = Math.min(this.player.hp + amt, this.player.maxHp); }
    addReroll(amt) { this.player.rerolls += amt; }

    endTurn() {
        if (this.turnState !== 'player') return;
        this.turnState = 'enemy';
        this.selectedHandIndex = null;
        this.updateUI();

        setTimeout(() => {
            if (this.enemy.currentHp > 0) {
                let finalDmg = this.enemy.dmg; 
                
                if (this.currentMod.id === 'rage') finalDmg += 2;

                if (this.currentMod.id === 'fog') {
                    let variance = Math.floor(Math.random() * 6) - 2; 
                    finalDmg += variance;
                    if (finalDmg < 0) finalDmg = 0;
                    this.log(`è¿·é›¾æ”»å‡»: ${finalDmg} ç‚¹!`);
                }
                
                let damageBlocked = Math.min(this.player.armor, finalDmg);
                let actualDmg = Math.max(0, finalDmg - this.player.armor);
                
                this.player.armor = Math.max(0, this.player.armor - finalDmg);
                
                if (actualDmg > 0) {
                    this.player.hp -= actualDmg;
                    this.shake('game-container');
                    if (this.currentMod.id !== 'fog') {
                        this.log(`ğŸ’” å—åˆ° ${actualDmg} ä¼¤å®³`);
                    }
                } else {
                    this.log(`ğŸ›¡ï¸ å®Œç¾é˜²å¾¡ï¼`);
                }

                if (this.player.hp <= 0) {
                    this.player.hp = 0;
                    this.showRewardModal("YOU DIED", `æ­¢æ­¥äºç¬¬ ${this.floor} å±‚`, true);
                } else {
                    this.turnCount++;
                    this.startTurn();
                }
            }
            this.updateUI();
        }, 800);
    }

    checkWin() {
        if (this.enemy.currentHp <= 0) {
            this.turnState = 'win';
            setTimeout(() => this.winBattle(), 600);
        }
    }

    winBattle() {
        // å¦‚æœæ˜¯æœ€åä¸€å±‚ (8å±‚)
        if (this.floor === ENEMIES_DB.length) {
            this.showRewardModal("ä¼ è¯´è¾¾æˆ", "æ­å–œï¼ä½ å‡»è´¥äº†æ·±æ¸Šé­”é¾™ï¼Œå¾æœäº†ç»å¢ƒéª°å­ï¼", true);
            // ä¿®æ”¹æŒ‰é’®æ–‡å­—
            const btn = document.querySelector('.reward-option');
            if(btn) btn.innerHTML = `<strong>ğŸ† å†æ¥ä¸€å±€</strong>`;
            return;
        }

        const rewards = [];
        
        rewards.push({ 
            name: "ğŸ©¹ åŒ…æ‰ä¼¤å£", desc: "å›å¤ 10 HP",
            fn: () => { this.healPlayer(10); this.nextFloor(); } 
        });

        const newItem = ITEMS_DB[Math.floor(Math.random() * ITEMS_DB.length)];
        const hasItem = this.inventory.find(i => i.id === newItem.id);
        
        if (hasItem) {
            rewards.push({
                name: `âœ¨ å¼ºåŒ–è£…å¤‡`, desc: `${newItem.icon}${newItem.name} ç­‰çº§ +1`,
                fn: () => { this.addItem(newItem.id); this.nextFloor(); }
            });
        } else {
            rewards.push({
                name: `ğŸ—¡ï¸ è·å–è£…å¤‡`, desc: `${newItem.icon}${newItem.name}`,
                fn: () => { this.addItem(newItem.id); this.nextFloor(); }
            });
        }

        // åœ¨ç¬¬2, 4, 6å±‚ç»™äºˆéª°å­å¥–åŠ±ï¼Œä¿è¯8å±‚é€šå…³çš„æˆ˜åŠ›
        if (this.floor === 2 || this.floor === 4 || this.floor === 6) {
            rewards.push({
                name: "ğŸ² æ‰©å±•éª°å­", desc: "æ¯å›åˆéª°å­ +1",
                fn: () => { this.player.diceCount++; this.nextFloor(); }
            });
        } else {
            rewards.push({
                name: "â¤ï¸ å¼ºèº«å¥ä½“", desc: "æœ€å¤§ç”Ÿå‘½ +5",
                fn: () => { this.player.maxHp+=5; this.player.hp+=5; this.nextFloor(); }
            });
        }

        this.showRewardModal("æˆ˜æ–—èƒœåˆ©", "é€‰æ‹©ä½ çš„å¥–åŠ±", false, rewards);
    }

    nextFloor() {
        this.floor++;
        document.getElementById('reward-modal').classList.remove('active');
        this.initFloor();
    }

    addItem(id) {
        const existing = this.inventory.find(i => i.id === id);
        if (existing) existing.level++;
        else this.inventory.push({ id: id, level: 0, storedDice: [] });
    }

    updateUI() {
        // HUD
        document.getElementById('hp-val').innerText = this.player.hp;
        document.getElementById('max-hp-val').innerText = this.player.maxHp;
        document.getElementById('armor-val').innerText = this.player.armor;
        document.getElementById('floor-val').innerText = this.floor;
        
        const btnReroll = document.getElementById('btn-reroll');
        document.getElementById('reroll-count').innerText = this.player.rerolls;
        btnReroll.disabled = this.player.rerolls <= 0 || this.handDice.length === 0;

        // Modifier
        const modEl = document.getElementById('modifier-area');
        if (this.currentMod.id !== 'normal') {
            modEl.style.display = 'flex';
            modEl.innerHTML = `<span>${this.currentMod.desc}</span>`;
            modEl.style.color = this.currentMod.color;
            modEl.style.borderColor = this.currentMod.color;
        } else {
            modEl.style.display = 'none';
        }

        // Enemy
        if (this.enemy) {
            document.getElementById('enemy-name').innerText = this.enemy.name;
            document.getElementById('enemy-hp-text').innerText = `${this.enemy.currentHp}/${this.enemy.maxHp}`;
            document.getElementById('enemy-avatar').innerText = this.enemy.emoji;
            
            let intentStr = "";
            if (this.enemy.currentHp <= 0) intentStr = "ğŸ’€ å·²å‡»è´¥";
            else if (this.currentMod.id === 'fog') intentStr = "âš ï¸ æ„å›¾ä¸æ˜ (?)";
            else intentStr = `âš ï¸ å‡†å¤‡æ”»å‡» ${this.enemy.dmg} ${this.currentMod.id==='rage' ? '(+2)':''}`;
            
            document.getElementById('enemy-intent').innerText = intentStr;
            
            const pct = (this.enemy.currentHp / this.enemy.maxHp) * 100;
            document.getElementById('enemy-hp-fill').style.width = `${pct}%`;

            // å›åˆæ•°æ˜¾ç¤ºä¼˜åŒ–
            const tc = document.getElementById('turn-counter');
            // åŠ ä¸Šâ€œå›åˆæ•°â€å­—æ ·
            tc.innerText = `â³ å›åˆæ•° ${this.turnCount}/${this.maxTurns}`;
            if (this.turnCount > this.maxTurns) {
                tc.classList.add('danger');
                tc.innerText = `âš ï¸ è¶…è½½ +${this.turnCount - this.maxTurns}`;
            } else {
                tc.classList.remove('danger');
            }
        }

        // Hand
        const handArea = document.getElementById('hand-area');
        handArea.innerHTML = '';
        this.handDice.forEach((d, idx) => {
            const wrapper = document.createElement('div');
            wrapper.innerHTML = getDieHTML(d.value);
            const dieEl = wrapper.firstElementChild;
            if (this.selectedHandIndex === idx) dieEl.classList.add('selected');
            dieEl.onclick = () => this.selectHandDie(idx);
            handArea.appendChild(dieEl);
        });

        // Board
        const boardArea = document.getElementById('board-area');
        boardArea.innerHTML = '';
        this.inventory.forEach((item, idx) => {
            const dbItem = ITEMS_DB.find(i => i.id === item.id);
            const el = document.createElement('div');
            el.className = `card ${this.selectedHandIndex !== null ? 'active-target' : ''}`;
            
            let storedHtml = '';
            item.storedDice.forEach(sd => {
                let bonus = sd.bonus ? `<span class="bonus-text">${sd.bonus}</span>` : '';
                storedHtml += `<div style="position:relative;">${getDieHTML(sd.value)} ${bonus}</div>`;
            });

            let lvlBadge = item.level > 0 ? `<span class="card-lvl">+${item.level}</span>` : '';
            let dynDesc = dbItem.desc; 
            if(item.level > 0) dynDesc += ` (Lv.${item.level})`;

            el.innerHTML = `
                <div class="card-header">
                    <span>${dbItem.icon} ${dbItem.name}</span> ${lvlBadge}
                </div>
                <div class="card-desc">${dynDesc}</div>
                <div class="card-slots">${storedHtml}</div>
            `;
            el.onclick = () => this.useItem(idx);
            boardArea.appendChild(el);
        });
    }

    log(msg) { document.getElementById('log-area').innerText = msg; }
    shake(id) {
        const el = document.getElementById(id);
        el.classList.remove('shake');
        void el.offsetWidth;
        el.classList.add('shake');
    }

    showRewardModal(title, msg, isGameOver, options = []) {
        const modal = document.getElementById('reward-modal');
        document.getElementById('reward-title').innerText = title;
        document.getElementById('reward-msg').innerText = msg;
        const optsDiv = document.getElementById('reward-options');
        optsDiv.innerHTML = '';

        if (isGameOver) {
            const btn = document.createElement('div');
            btn.className = 'reward-option';
            btn.innerHTML = `<strong>ğŸ”„ é‡æ–°å¼€å§‹</strong><small>å†æ¬¡æŒ‘æˆ˜åœ°ä¸‹åŸ</small>`;
            btn.onclick = () => location.reload();
            optsDiv.appendChild(btn);
        } else {
            options.forEach(opt => {
                const btn = document.createElement('div');
                btn.className = 'reward-option';
                btn.innerHTML = `<strong>${opt.name}</strong><small>${opt.desc}</small>`;
                btn.onclick = opt.fn;
                optsDiv.appendChild(btn);
            });
        }
        modal.classList.add('active');
    }
}

function toggleRules() {
    document.getElementById('rules-modal').classList.toggle('active');
}

const game = new Game();
</script>
</body>
</html>