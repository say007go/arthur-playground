<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>国际跳棋 (by Arthur)</title>
    <style>
        :root {
            --bg-color: #0f1c15;
            --board-border: #3e2211;
            --cell-light: #eecfa1;
            --cell-dark: #5c3a21;
            --highlight: #d4af37; /* 金色 */
            --p1-main: #b80a0a;    /* 红棋主色 */
            --p2-main: #1f1f1f;    /* 黑棋主色 */
        }

        * { box-sizing: border-box; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at center, #1b3a2a 0%, #050a08 100%);
            color: #fff;
            font-family: 'Times New Roman', serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* 关键修改：强制占满屏幕高度，防止滚动，确保Flex垂直居中生效 */
            height: 100vh; 
            overflow: hidden; 
        }

        /* 顶部 UI - 更加紧凑 */
        header {
            width: 100%;
            padding: 8px 15px; /* 减小内边距 */
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.4);
            border-bottom: 1px solid var(--highlight);
            z-index: 10;
            flex-shrink: 0; /* 防止被挤压 */
        }

        h1 {
            margin: 0;
            font-size: clamp(1rem, 4vw, 1.5rem); /* 字体稍微调小一点适配手机 */
            color: var(--highlight);
            text-shadow: 0 2px 4px #000;
            letter-spacing: 1px;
        }

        .btn-rule {
            margin-left: 10px;
            background: transparent;
            border: 1px solid var(--highlight);
            color: var(--highlight);
            border-radius: 50%;
            width: 22px;
            height: 22px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.2s;
        }
        .btn-rule:hover { background: var(--highlight); color: #000; }

        /* 控制面板 - 紧凑排列 */
        .controls {
            margin: 8px 0 5px 0; /* 减小外边距 */
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            z-index: 5;
            flex-shrink: 0;
        }

        select, button {
            background: linear-gradient(to bottom, #2b2b2b, #1a1a1a);
            color: var(--highlight);
            border: 1px solid #555;
            border-bottom: 2px solid var(--highlight);
            padding: 4px 12px; /* 减小按钮内边距 */
            font-size: 13px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            outline: none;
            transition: transform 0.1s;
        }
        button:active { transform: translateY(2px); }

        .status-bar {
            margin-bottom: 5px; /* 减小下边距 */
            color: #ddd;
            font-size: 0.95rem;
            text-shadow: 0 1px 2px #000;
            min-height: 1.2em;
            flex-shrink: 0;
        }

        /* 棋盘容器 - 核心居中逻辑 */
        .board-wrapper {
            flex-grow: 1; /* 占据剩余所有空间 */
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center; /* 在剩余空间内垂直居中 */
            overflow: hidden; /* 防止滑动条出现 */
            padding: 5px;
            position: relative;
        }

        #board {
            /* 手机端加大占比，PC端限制最大尺寸 */
            width: 96vmin; 
            height: 96vmin;
            
            max-width: 580px; 
            max-height: 580px;
            
            background-color: var(--board-border);
            padding: 8px;
            border-radius: 6px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.8), inset 0 0 20px rgba(0,0,0,0.6);
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 6px solid #2a150a;
            position: relative;
            transition: transform 0.6s ease-in-out;
        }

        /* 针对超窄屏手机的微调 */
        @media (max-width: 400px) {
            h1 { font-size: 1.1rem; }
            .controls { gap: 5px; margin: 5px 0; }
            select, button { font-size: 12px; padding: 3px 8px; }
            #board { border-width: 4px; padding: 4px; }
        }

        #board.rotate-180 { transform: rotate(180deg); }

        .cell {
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            position: relative;
        }

        .cell.light { 
            background: var(--cell-light); 
            background-image: url('data:image/svg+xml;utf8,<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><rect width="100%" height="100%" fill="none"/><path d="M0 0 L100 100 M100 0 L0 100" stroke="%23dcc090" stroke-width="0.5" opacity="0.5"/></svg>');
        }
        .cell.dark { 
            background: var(--cell-dark);
            box-shadow: inset 0 0 8px rgba(0,0,0,0.4);
        }

        .cell.highlight::after {
            content: ''; position: absolute;
            width: 25%; height: 25%;
            background: #00ff00; border-radius: 50%;
            box-shadow: 0 0 8px #00ff00;
            z-index: 1; opacity: 0.6; pointer-events: none;
        }
        .cell.selected {
            background-color: #8c7b38 !important;
            box-shadow: inset 0 0 15px rgba(255, 255, 0, 0.3);
        }
        .cell.last-move {
            background-color: rgba(212, 175, 55, 0.2) !important;
        }

        /* 拟真棋子 */
        .piece {
            width: 82%; height: 82%;
            border-radius: 50%;
            position: relative;
            z-index: 2;
            cursor: pointer;
            box-shadow: 
                0 3px 5px rgba(0,0,0,0.6), 
                inset 0 -3px 5px rgba(0,0,0,0.5), 
                inset 0 3px 5px rgba(255,255,255,0.4);
            transition: transform 0.2s;
        }
        .piece::before {
            content: ''; position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 65%; height: 65%;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.15);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
        }
        .piece.red {
            background: radial-gradient(circle at 35% 35%, #ff5e5e, var(--p1-main) 60%, #4a0000);
            border: 1px solid #330000;
        }
        .piece.black {
            background: radial-gradient(circle at 35% 35%, #666, var(--p2-main) 60%, #000);
            border: 1px solid #000;
        }
        .piece.king::after {
            content: '♔'; font-size: 2em; color: #d4af37;
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -55%);
            text-shadow: 0 1px 1px rgba(0,0,0,0.8);
        }
        #board.rotate-180 .piece { transform: rotate(180deg); }
        @media (max-width: 600px) { .piece.king::after { font-size: 1.4rem; } }

        /* 移动动画 */
        .piece.moving {
            position: absolute; z-index: 100; pointer-events: none;
            box-shadow: 0 15px 25px rgba(0,0,0,0.5);
            transition: left 0.4s ease-in-out, top 0.4s ease-in-out;
        }

        /* 模态框 */
        .modal {
            display: none; position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 200; justify-content: center; align-items: center;
        }
        .modal-content {
            background: #1a1a1a; border: 2px solid var(--highlight);
            padding: 25px; border-radius: 8px;
            max-width: 90%; width: 400px; max-height: 80vh;
            overflow-y: auto; position: relative;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.2);
        }
        .modal h2 { color: var(--highlight); margin-top: 0; text-align: center; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .modal ul { padding-left: 20px; }
        .modal li { font-size: 14px; line-height: 1.8; color: #ccc; margin-bottom: 5px; }
        .close-modal {
            position: absolute; top: 10px; right: 15px;
            color: #888; font-size: 28px; cursor: pointer; line-height: 20px;
        }
        .developer {
            margin-top: 20px; border-top: 1px solid #333; padding-top: 15px;
            text-align: center; font-size: 13px; color: var(--highlight); font-style: italic;
        }
    </style>
</head>
<body>

<header>
    <h1>国际跳棋 (by Arthur)</h1>
    <button class="btn-rule" onclick="toggleModal(true)">?</button>
</header>

<div class="controls">
    <select id="gameMode">
        <option value="pve">人机对战 (PVE)</option>
        <option value="pvp">双人对战 (PVP)</option>
    </select>
    <select id="difficulty">
        <option value="1">难度: 简单</option>
        <option value="3" selected>难度: 中等</option>
        <option value="5">难度: 极难</option>
    </select>
    <button onclick="game.initGame()">重新开始</button>
</div>

<div class="status-bar" id="status">准备开始...</div>

<div class="board-wrapper">
    <div id="board"></div>
</div>

<div id="ruleModal" class="modal">
    <div class="modal-content">
        <span class="close-modal" onclick="toggleModal(false)">&times;</span>
        <h2>游戏规则</h2>
        <ul>
            <li><strong>胜负：</strong>吃光对方或让对方无路可走即获胜。</li>
            <li><strong>移动：</strong>棋子沿深色格斜向移动一格。</li>
            <li><strong>强制吃子：</strong>若紧邻对手棋子且后方为空，<span style="color:#ff5e5e">必须</span>跳过吃子。</li>
            <li><strong>连跳：</strong>吃子后若还能吃，必须继续连跳。</li>
            <li><strong>王棋：</strong>到达底线升变为王，可向后移动。</li>
            <li><strong>PVE说明：</strong>人机模式下，您的阵营(红/黑)随机分配。</li>
        </ul>
        <div class="developer">开发者：ArthurZhu</div>
    </div>
</div>

<script>
/**
 * 国际跳棋 (8x8) 
 * 修正版：优化手机端布局间距
 */

const BOARD_SIZE = 8;
const PLAYER_RED = 1;
const PLAYER_BLACK = 2;
const KING_RED = 3;
const KING_BLACK = 4;

class CheckersGame {
    constructor() {
        this.boardData = [];
        this.turn = PLAYER_RED; 
        this.selectedPiece = null;
        this.validMoves = [];
        this.gameOver = false;
        this.isAnimating = false;
        
        this.mode = 'pve';
        this.difficulty = 3;
        this.playerSide = PLAYER_RED; 

        this.boardEl = document.getElementById('board');
        this.statusEl = document.getElementById('status');
        
        this.createBoardGrid();
    }

    createBoardGrid() {
        this.boardEl.innerHTML = '';
        for(let r=0; r<BOARD_SIZE; r++) {
            for(let c=0; c<BOARD_SIZE; c++) {
                const cell = document.createElement('div');
                cell.className = `cell ${(r+c)%2===0 ? 'light' : 'dark'}`;
                cell.id = `cell-${r}-${c}`;
                cell.onclick = () => this.handleCellClick(r, c);
                this.boardEl.appendChild(cell);
            }
        }
    }

    initGame() {
        this.turn = PLAYER_RED;
        this.selectedPiece = null;
        this.validMoves = [];
        this.gameOver = false;
        this.isAnimating = false;
        
        this.mode = document.getElementById('gameMode').value;
        this.difficulty = parseInt(document.getElementById('difficulty').value);

        if (this.mode === 'pve') {
            this.playerSide = Math.random() < 0.5 ? PLAYER_RED : PLAYER_BLACK;
        } else {
            this.playerSide = PLAYER_RED;
        }

        this.boardData = Array(8).fill(null).map(() => Array(8).fill(0));
        for(let r=0; r<BOARD_SIZE; r++) {
            for(let c=0; c<BOARD_SIZE; c++) {
                if((r + c) % 2 === 1) {
                    if(r < 3) this.boardData[r][c] = PLAYER_BLACK;
                    else if(r > 4) this.boardData[r][c] = PLAYER_RED;
                }
            }
        }

        this.adjustView();
        this.renderPieces();
        this.clearHighlights();
        this.updateStatus();

        if(this.mode === 'pve' && this.playerSide === PLAYER_BLACK) {
             setTimeout(() => this.makeAiMove(), 800);
        }
    }

    adjustView() {
        if (this.mode === 'pve' && this.playerSide === PLAYER_BLACK) {
            this.boardEl.classList.add('rotate-180');
        } else {
            this.boardEl.classList.remove('rotate-180');
        }
    }

    renderPieces() {
        for(let r=0; r<BOARD_SIZE; r++) {
            for(let c=0; c<BOARD_SIZE; c++) {
                const cell = document.getElementById(`cell-${r}-${c}`);
                while (cell.firstChild) cell.removeChild(cell.firstChild);

                const val = this.boardData[r][c];
                if(val !== 0) {
                    const piece = document.createElement('div');
                    piece.className = `piece ${ (val === PLAYER_RED || val === KING_RED) ? 'red' : 'black' }`;
                    if(val === KING_RED || val === KING_BLACK) piece.classList.add('king');
                    piece.dataset.r = r;
                    piece.dataset.c = c;
                    cell.appendChild(piece);
                }
            }
        }
    }

    clearHighlights() {
        const cells = document.querySelectorAll('.cell');
        cells.forEach(c => {
            c.classList.remove('highlight');
            c.classList.remove('selected');
            c.classList.remove('last-move');
        });
    }

    handleCellClick(r, c) {
        if(this.gameOver || this.isAnimating) return;
        if(this.mode === 'pve' && this.turn !== this.playerSide) return;

        const clickedVal = this.boardData[r][c];
        const isOwnPiece = this.isOwnPiece(clickedVal, this.turn);

        if(isOwnPiece) {
            const allMoves = this.getAllPossibleMoves(this.boardData, this.turn);
            const canJump = allMoves.some(m => m.jump);
            const movesForPiece = this.getMovesForPiece(this.boardData, r, c, clickedVal);

            if(canJump) {
                if(!movesForPiece.some(m => m.jump)) return;
                this.validMoves = movesForPiece.filter(m => m.jump);
            } else {
                this.validMoves = movesForPiece;
            }

            this.selectedPiece = {r, c};
            this.clearHighlights();
            document.getElementById(`cell-${r}-${c}`).classList.add('selected');
            this.validMoves.forEach(m => {
                document.getElementById(`cell-${m.toR}-${m.toC}`).classList.add('highlight');
            });
        } 
        else if(this.selectedPiece) {
            const move = this.validMoves.find(m => m.toR === r && m.toC === c);
            if(move) {
                this.executeMoveWithAnimation(move);
            }
        }
    }

    async executeMoveWithAnimation(move) {
        this.isAnimating = true;
        this.clearHighlights();

        const {fromR, fromC, toR, toC, jump} = move;
        const fromCell = document.getElementById(`cell-${fromR}-${fromC}`);
        const toCell = document.getElementById(`cell-${toR}-${toC}`);
        const pieceEl = fromCell.querySelector('.piece');

        if(!pieceEl) {
            this.finalizeMove(move);
            return;
        }

        const fromRect = fromCell.getBoundingClientRect();
        const toRect = toCell.getBoundingClientRect();

        const clone = pieceEl.cloneNode(true);
        clone.classList.add('moving');
        
        document.body.appendChild(clone);
        clone.style.width = fromRect.width * 0.82 + 'px';
        clone.style.height = fromRect.height * 0.82 + 'px';
        clone.style.left = (fromRect.left + fromRect.width*0.09) + 'px';
        clone.style.top = (fromRect.top + fromRect.height*0.09) + 'px';
        
        pieceEl.style.opacity = '0';
        clone.offsetHeight;

        clone.style.left = (toRect.left + toRect.width*0.09) + 'px';
        clone.style.top = (toRect.top + toRect.height*0.09) + 'px';

        await new Promise(resolve => setTimeout(resolve, 400));
        clone.remove();
        
        this.finalizeMove(move);
        this.isAnimating = false;
    }

    finalizeMove(move) {
        const {fromR, fromC, toR, toC, jump} = move;
        const pieceVal = this.boardData[fromR][fromC];

        this.boardData[toR][toC] = pieceVal;
        this.boardData[fromR][fromC] = 0;

        if(jump) {
            const midR = (fromR + toR) / 2;
            const midC = (fromC + toC) / 2;
            this.boardData[midR][midC] = 0;
        }

        let promoted = false;
        if(pieceVal === PLAYER_RED && toR === 0) {
            this.boardData[toR][toC] = KING_RED;
            promoted = true;
        } else if(pieceVal === PLAYER_BLACK && toR === 7) {
            this.boardData[toR][toC] = KING_BLACK;
            promoted = true;
        }

        this.renderPieces();
        document.getElementById(`cell-${fromR}-${fromC}`).classList.add('last-move');
        document.getElementById(`cell-${toR}-${toC}`).classList.add('last-move');

        let hasMultiJump = false;
        if(jump && !promoted) {
            const newMoves = this.getMovesForPiece(this.boardData, toR, toC, this.boardData[toR][toC]);
            const jumpMoves = newMoves.filter(m => m.jump);
            if(jumpMoves.length > 0) {
                hasMultiJump = true;
                this.selectedPiece = {r: toR, c: toC};
                this.validMoves = jumpMoves;
                document.getElementById(`cell-${toR}-${toC}`).classList.add('selected');
                jumpMoves.forEach(m => document.getElementById(`cell-${m.toR}-${m.toC}`).classList.add('highlight'));
                
                if(this.mode === 'pve' && this.turn !== this.playerSide) {
                     setTimeout(() => this.executeMoveWithAnimation(jumpMoves[0]), 400);
                     return;
                }
            }
        }

        if(!hasMultiJump) {
            this.endTurn();
        }
    }

    endTurn() {
        this.selectedPiece = null;
        this.validMoves = [];
        
        if(this.checkWin(this.turn === PLAYER_RED ? PLAYER_BLACK : PLAYER_RED)) return;

        this.turn = this.turn === PLAYER_RED ? PLAYER_BLACK : PLAYER_RED;
        this.updateStatus();

        if(this.mode === 'pve' && this.turn !== this.playerSide) {
            setTimeout(() => this.makeAiMove(), 600);
        }
    }

    checkWin(nextPlayer) {
        const moves = this.getAllPossibleMoves(this.boardData, nextPlayer);
        if(moves.length === 0) {
            this.gameOver = true;
            let winnerName = "";
            if(this.mode === 'pve') {
                winnerName = (nextPlayer !== this.playerSide) ? "你" : "电脑";
            } else {
                winnerName = nextPlayer === PLAYER_RED ? "黑方" : "红方";
            }
            const msg = `游戏结束！${winnerName} 获胜！`;
            this.statusEl.innerText = msg;
            setTimeout(() => alert(msg), 100);
            return true;
        }
        return false;
    }

    updateStatus() {
        let text = "";
        const turnName = this.turn === PLAYER_RED ? "红方" : "黑方";
        
        if(this.mode === 'pve') {
            if (this.turn === this.playerSide) {
                text = `轮到你了 (${turnName})`;
            } else {
                text = `电脑思考中 (${turnName})...`;
            }
        } else {
            text = `${turnName} 回合`;
        }
        this.statusEl.innerText = text;
    }

    isOwnPiece(val, player) {
        if(player === PLAYER_RED) return val === 1 || val === 3;
        if(player === PLAYER_BLACK) return val === 2 || val === 4;
        return false;
    }

    getAllPossibleMoves(board, player) {
        let moves = [];
        for(let r=0; r<BOARD_SIZE; r++) {
            for(let c=0; c<BOARD_SIZE; c++) {
                const val = board[r][c];
                if(this.isOwnPiece(val, player)) {
                    moves = moves.concat(this.getMovesForPiece(board, r, c, val));
                }
            }
        }
        const jumpMoves = moves.filter(m => m.jump);
        return jumpMoves.length > 0 ? jumpMoves : moves;
    }

    getMovesForPiece(board, r, c, val) {
        const moves = [];
        const isKing = val === 3 || val === 4;
        const player = (val === 1 || val === 3) ? PLAYER_RED : PLAYER_BLACK;
        
        let dirs = [];
        if(player === PLAYER_RED) dirs.push([-1, -1], [-1, 1]);
        if(player === PLAYER_BLACK) dirs.push([1, -1], [1, 1]);
        if(isKing) {
            if(player === PLAYER_RED) dirs.push([1, -1], [1, 1]); 
            else dirs.push([-1, -1], [-1, 1]);
        }

        dirs.forEach(([dr, dc]) => {
            const nr = r + dr, nc = c + dc;
            if(this.isValidPos(nr, nc) && board[nr][nc] === 0) {
                moves.push({fromR: r, fromC: c, toR: nr, toC: nc, jump: false});
            }
            const jr = r + dr*2, jc = c + dc*2;
            if(this.isValidPos(jr, jc) && board[jr][jc] === 0) {
                const midVal = board[nr][nc];
                if(midVal !== 0 && !this.isOwnPiece(midVal, player)) {
                    moves.push({fromR: r, fromC: c, toR: jr, toC: jc, jump: true});
                }
            }
        });
        return moves;
    }

    isValidPos(r, c) {
        return r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE;
    }

    makeAiMove() {
        if(this.gameOver) return;
        const depth = this.difficulty; 
        const aiPlayer = this.turn;
        
        setTimeout(() => {
            const bestMove = this.minimaxRoot(depth, aiPlayer);
            if(bestMove) {
                this.executeMoveWithAnimation(bestMove);
            } else {
                console.log("AI无路可走");
            }
        }, 10);
    }

    minimaxRoot(depth, aiPlayer) {
        const possibleMoves = this.getAllPossibleMoves(this.boardData, aiPlayer);
        if(possibleMoves.length === 0) return null;
        if(possibleMoves.length === 1) return possibleMoves[0];

        possibleMoves.sort(() => Math.random() - 0.5);

        let bestMoveVal = -99999;
        let bestMoveFound = possibleMoves[0];

        for(let i = 0; i < possibleMoves.length; i++) {
            const move = possibleMoves[i];
            const newBoard = this.simulateMove(this.boardData, move);
            const val = this.minimax(newBoard, depth - 1, -100000, 100000, false, aiPlayer);
            if(val > bestMoveVal) {
                bestMoveVal = val;
                bestMoveFound = move;
            }
        }
        return bestMoveFound;
    }

    minimax(board, depth, alpha, beta, isMaximizing, aiPlayer) {
        if(depth === 0) return this.evaluateBoard(board, aiPlayer);

        const currentPlayer = isMaximizing ? aiPlayer : (aiPlayer===PLAYER_RED?PLAYER_BLACK:PLAYER_RED);
        const possibleMoves = this.getAllPossibleMoves(board, currentPlayer);

        if(possibleMoves.length === 0) {
            return isMaximizing ? -10000 : 10000;
        }

        if(isMaximizing) {
            let maxEval = -99999;
            for(let move of possibleMoves) {
                const newBoard = this.simulateMove(board, move);
                const evalVal = this.minimax(newBoard, depth - 1, alpha, beta, false, aiPlayer);
                maxEval = Math.max(maxEval, evalVal);
                alpha = Math.max(alpha, evalVal);
                if(beta <= alpha) break;
            }
            return maxEval;
        } else {
            let minEval = 99999;
            for(let move of possibleMoves) {
                const newBoard = this.simulateMove(board, move);
                const evalVal = this.minimax(newBoard, depth - 1, alpha, beta, true, aiPlayer);
                minEval = Math.min(minEval, evalVal);
                beta = Math.min(beta, evalVal);
                if(beta <= alpha) break;
            }
            return minEval;
        }
    }

    simulateMove(board, move) {
        const newBoard = board.map(row => [...row]);
        const {fromR, fromC, toR, toC, jump} = move;
        const val = newBoard[fromR][fromC];
        newBoard[toR][toC] = val;
        newBoard[fromR][fromC] = 0;
        if(jump) {
            newBoard[(fromR+toR)/2][(fromC+toC)/2] = 0;
        }
        if(val === PLAYER_RED && toR === 0) newBoard[toR][toC] = KING_RED;
        if(val === PLAYER_BLACK && toR === 7) newBoard[toR][toC] = KING_BLACK;
        return newBoard;
    }

    evaluateBoard(board, aiPlayer) {
        let score = 0;
        const opponent = aiPlayer === PLAYER_RED ? PLAYER_BLACK : PLAYER_RED;

        for(let r=0; r<BOARD_SIZE; r++) {
            for(let c=0; c<BOARD_SIZE; c++) {
                const val = board[r][c];
                if(val === 0) continue;
                
                let pieceScore = 10;
                if(val === KING_RED || val === KING_BLACK) pieceScore = 30;

                if(this.isOwnPiece(val, aiPlayer)) {
                    score += pieceScore;
                    if(aiPlayer === PLAYER_BLACK) score += r;
                    else score += (7-r);
                } else {
                    score -= pieceScore;
                    if(opponent === PLAYER_BLACK) score -= r;
                    else score -= (7-r);
                }
            }
        }
        return score;
    }
}

const game = new CheckersGame();
game.initGame();

document.getElementById('gameMode').addEventListener('change', () => game.initGame());
document.getElementById('difficulty').addEventListener('change', () => game.initGame());

function toggleModal(show) {
    document.getElementById('ruleModal').style.display = show ? 'flex' : 'none';
}
window.onclick = function(event) {
    const modal = document.getElementById('ruleModal');
    if (event.target == modal) {
        modal.style.display = "none";
    }
}
</script>
</body>
</html>