<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>黑白棋（by Arthur）</title>
    <style>
        :root {
            --wood-dark: #3e2723;
            --wood-light: #5d4037;
            --felt-green: #1b5e20;
            --gold-text: #ffd700;
            --gold-shadow: #b8860b;
            --board-size: min(90vw, 90vh, 520px); 
            --cell-size: calc(var(--board-size) / 8);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(circle at 50% 30%, #3a3a3a 0%, #1a1a1a 40%, #000000 100%);
            font-family: "Verdana", "Microsoft YaHei", sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* 顶部标题栏 */
        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            gap: 15px;
            z-index: 10;
        }

        h1 {
            font-size: clamp(1rem, 3.5vw, 2rem);
            margin: 0;
            font-weight: 800;
            background: linear-gradient(to bottom, #fff, #ffd700, #b8860b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.5));
            letter-spacing: 1px;
            text-transform: uppercase;
            white-space: nowrap; 
        }

        /* 规则按钮 */
        .info-btn {
            background: linear-gradient(145deg, #ffd700, #b8860b);
            border: 2px solid #fff;
            color: #3e2723;
            font-weight: 900;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
            font-family: sans-serif;
            font-size: 1rem;
            flex-shrink: 0;
        }

        /* 控制面板 */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 600px;
            padding: 0 10px;
        }

        select, button {
            background: linear-gradient(to bottom, #5d4037, #3e2723);
            color: #ffd700;
            border: 2px solid #8d6e63;
            padding: 10px 20px;
            font-family: inherit;
            font-weight: bold;
            font-size: 0.95rem;
            border-radius: 6px;
            box-shadow: 0 5px 10px rgba(0,0,0,0.5);
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover, select:hover {
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255,215,0,0.3);
        }

        button:active {
            transform: translateY(2px);
        }

        /* 记分板 */
        .scoreboard {
            display: flex;
            justify-content: space-between;
            width: var(--board-size);
            margin-bottom: 15px;
            padding: 12px 15px;
            background: rgba(0,0,0,0.7);
            border-radius: 12px;
            border: 1px solid #5d4037;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        .player-score {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1rem;
            font-weight: bold;
            color: #ccc;
            transition: color 0.3s;
        }

        .player-score.active-turn {
            color: #ffd700;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }

        .turn-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #444;
            box-shadow: inset 0 0 2px #000;
            transition: all 0.3s;
        }

        .active-turn .turn-indicator {
            background: #00ff00;
            box-shadow: 0 0 8px #00ff00;
        }
        
        .name-label {
            font-size: 0.9em;
        }

        /* 棋盘外框 */
        .board-frame {
            padding: 15px;
            background: repeating-linear-gradient(
                45deg,
                var(--wood-dark),
                var(--wood-dark) 10px,
                var(--wood-light) 10px,
                var(--wood-light) 20px
            );
            border-radius: 12px;
            box-shadow: 0 25px 60px rgba(0,0,0,0.9), inset 0 0 20px rgba(0,0,0,0.8);
            border: 5px solid #281810;
        }

        /* 棋盘区域 */
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: var(--board-size);
            height: var(--board-size);
            background-color: var(--felt-green);
            background-image: radial-gradient(transparent 0%, rgba(0,0,0,0.4) 100%);
            border: 2px solid #111;
            position: relative;
            perspective: 800px; /* 为3D翻转提供透视 */
        }

        .cell {
            width: 100%;
            height: 100%;
            border: 1px solid rgba(0,0,0,0.25);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* ---- 棋子样式重构（支持3D翻转） ---- */
        .disc {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            position: relative;
            transform-style: preserve-3d; /* 保持3D空间 */
            transition: transform 0.6s cubic-bezier(0.4, 0.2, 0.2, 1); /* 翻转动画 */
            z-index: 2;
        }
        
        /* 进场动画：仅在新棋子生成时触发 */
        @keyframes pop {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .disc.newly-placed {
            animation: pop 0.25s ease-out;
        }

        /* 棋子的两面 */
        .face {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            backface-visibility: hidden; /* 背面不可见 */
            box-shadow: 2px 4px 6px rgba(0,0,0,0.6);
            /* 解决3D渲染边缘锯齿 */
            -webkit-backface-visibility: hidden; 
        }

        /* 黑色面 (正面，0度) */
        .face.black {
            background: radial-gradient(circle at 35% 35%, #666, #000);
            transform: rotateY(0deg);
        }

        /* 白色面 (背面，180度) */
        .face.white {
            background: radial-gradient(circle at 35% 35%, #fff, #ccc);
            transform: rotateY(180deg);
        }

        /* 翻转状态：当棋子需要显示白色时，旋转180度 */
        .disc.flipped {
            transform: rotateY(180deg);
        }

        /* 可落子提示 */
        .legal-move {
            position: absolute;
            width: 25%;
            height: 25%;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1;
            box-shadow: 0 0 2px rgba(255,255,255,0.2);
        }
        
        .legal-move:hover {
            background: rgba(0, 0, 0, 0.6);
            transform: scale(1.5);
            border: 2px solid rgba(255,215,0,0.5);
        }

        /* 弹窗样式不变 */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            justify-content: center; align-items: center;
            z-index: 100;
            padding: 20px;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: linear-gradient(135deg, #2c2c2c, #1a1a1a);
            border: 2px solid #ffd700;
            padding: 25px;
            border-radius: 10px;
            max-width: 500px; width: 100%;
            color: #ddd;
            position: relative;
            max-height: 80vh; overflow-y: auto;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.15);
        }
        .modal-title {
            color: #ffd700; font-size: 1.5rem; margin-bottom: 15px;
            text-align: center; border-bottom: 1px solid #555; padding-bottom: 10px; font-weight: bold;
        }
        .modal-text { line-height: 1.6; font-size: 0.95rem; }
        .close-btn {
            display: block; margin: 20px auto 0;
            background: #ffd700; color: #000;
            border: none; padding: 10px 35px;
            font-weight: bold; font-size: 1rem;
        }
        .modal-footer {
            margin-top: 20px; font-size: 0.8rem; color: #888;
            text-align: center; border-top: 1px solid #444; padding-top: 10px;
        }

        @media (max-width: 600px) {
            .controls { gap: 8px; }
            select, button { padding: 8px 12px; font-size: 0.8rem; }
            .player-score { font-size: 0.85rem; }
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>黑白棋（by Arthur）</h1>
        <div class="info-btn" onclick="openRules()">?</div>
    </div>

    <div class="scoreboard">
        <div class="player-score active-turn" id="score-black-container">
            <div class="turn-indicator"></div>
            <div style="width: 24px; height: 24px; border-radius: 50%; background: #000; border: 1px solid #666; margin: 0 8px; box-shadow: 1px 1px 3px rgba(255,255,255,0.2);"></div>
            <span><span id="label-black" class="name-label">黑方</span>: <span id="score-black" style="font-size:1.2em; color:#fff;">2</span></span>
        </div>
        <div class="player-score" id="score-white-container">
            <span><span id="label-white" class="name-label">白方</span>: <span id="score-white" style="font-size:1.2em; color:#fff;">2</span></span>
            <div style="width: 24px; height: 24px; border-radius: 50%; background: #fff; margin: 0 8px; box-shadow: 1px 1px 3px rgba(0,0,0,0.5);"></div>
            <div class="turn-indicator"></div>
        </div>
    </div>

    <div class="board-frame">
        <div class="board" id="board">
            <!-- Grid generated by JS -->
        </div>
    </div>

    <div class="controls" style="margin-top: 25px;">
        <select id="game-mode">
            <option value="pve">人机对战 (PVE)</option>
            <option value="pvp">双人对战 (PVP)</option>
        </select>
        <select id="difficulty">
            <option value="1">难度：新手 (Easy)</option>
            <option value="2" selected>难度：进阶 (Medium)</option>
            <option value="3">难度：大师 (Hard)</option>
        </select>
        <button onclick="newGame()">新游戏</button>
    </div>

    <!-- 规则弹窗 -->
    <div class="modal-overlay" id="rulesModal">
        <div class="modal-content">
            <div class="modal-title">游戏规则</div>
            <div class="modal-text">
                <p>1. <strong>基本规则：</strong> 游戏由黑方先行。双方轮流落子。</p>
                <p>2. <strong>吃子：</strong> 落子时，如果您的棋子与棋盘上已有的己方棋子夹住了对手的棋子（横、竖、斜方向均可），对手的棋子就会翻转变成您的颜色。</p>
                <p>3. <strong>有效落子：</strong> 您必须在能至少翻转对手一颗棋子的地方落子。如果没有地方可下，则必须弃权（Pass），由对方继续。</p>
                <p>4. <strong>胜负：</strong> 当双方都无法落子或棋盘下满时，游戏结束。棋子多的一方获胜。</p>
            </div>
            <div class="modal-footer">
                开发者：ArthurZhu
            </div>
            <button class="close-btn" onclick="closeRules()">关闭</button>
        </div>
    </div>

    <script>
        // 常量定义
        const BLACK = 1;
        const WHITE = 2;
        const EMPTY = 0;
        const BOARD_SIZE = 8;
        
        // 游戏状态
        let board = [];
        let currentPlayer = BLACK;
        let isGameOver = false;
        let gameMode = 'pve'; 
        let difficulty = 2; 
        let isComputerThinking = false;
        let humanSide = BLACK; 

        // 权重矩阵
        const WEIGHTS = [
            [100, -20, 10,  5,  5, 10, -20, 100],
            [-20, -50, -2, -2, -2, -2, -50, -20],
            [ 10,  -2, -1, -1, -1, -1,  -2,  10],
            [  5,  -2, -1, -1, -1, -1,  -2,   5],
            [  5,  -2, -1, -1, -1, -1,  -2,   5],
            [ 10,  -2, -1, -1, -1, -1,  -2,  10],
            [-20, -50, -2, -2, -2, -2, -50, -20],
            [100, -20, 10,  5,  5, 10, -20, 100]
        ];

        const directions = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1],           [0, 1],
            [1, -1],  [1, 0],  [1, 1]
        ];

        // 初始化
        window.onload = function() {
            initBoardHTML();
            newGame();
            
            document.getElementById('game-mode').addEventListener('change', (e) => {
                gameMode = e.target.value;
                const diffSelect = document.getElementById('difficulty');
                diffSelect.style.display = (gameMode === 'pvp') ? 'none' : 'inline-block';
                newGame();
            });

            document.getElementById('difficulty').addEventListener('change', (e) => {
                difficulty = parseInt(e.target.value);
                newGame();
            });
        };

        function initBoardHTML() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    let cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.onclick = () => handleUserClick(r, c);
                    boardEl.appendChild(cell);
                }
            }
        }

        function newGame() {
            // 清空棋盘数据
            board = Array(8).fill(null).map(() => Array(8).fill(EMPTY));
            
            // 彻底清空UI（防止旧游戏残余）
            const allCells = document.querySelectorAll('.cell');
            allCells.forEach(cell => cell.innerHTML = '');

            // 初始布局
            board[3][3] = WHITE;
            board[3][4] = BLACK;
            board[4][3] = BLACK;
            board[4][4] = WHITE;

            currentPlayer = BLACK;
            isGameOver = false;
            isComputerThinking = false;
            
            // PVE模式下随机分配阵营并更新UI
            if (gameMode === 'pve') {
                humanSide = Math.random() < 0.5 ? BLACK : WHITE;
                if (humanSide === BLACK) {
                    document.getElementById('label-black').innerText = "黑方 (玩家)";
                    document.getElementById('label-white').innerText = "白方 (电脑)";
                } else {
                    document.getElementById('label-black').innerText = "黑方 (电脑)";
                    document.getElementById('label-white').innerText = "白方 (玩家)";
                }
            } else {
                document.getElementById('label-black').innerText = "黑方";
                document.getElementById('label-white').innerText = "白方";
                humanSide = BLACK; 
            }
            
            updateBoardUI();
            
            if (gameMode === 'pve' && humanSide === WHITE) {
                isComputerThinking = true;
                setTimeout(computerMove, 1000); 
                checkGameStateUIOnly();
            } else {
                checkGameState();
            }
        }
        
        function checkGameStateUIOnly() {
            updateScore();
            document.getElementById('score-black-container').classList.toggle('active-turn', currentPlayer === BLACK);
            document.getElementById('score-white-container').classList.toggle('active-turn', currentPlayer === WHITE);
        }

        function getFlips(r, c, player, currentBoard) {
            if (currentBoard[r][c] !== EMPTY) return [];
            let flips = [];
            let opponent = player === BLACK ? WHITE : BLACK;
            for (let [dr, dc] of directions) {
                let rCurr = r + dr;
                let cCurr = c + dc;
                let potentialFlips = [];
                while (rCurr >= 0 && rCurr < 8 && cCurr >= 0 && cCurr < 8 && currentBoard[rCurr][cCurr] === opponent) {
                    potentialFlips.push({r: rCurr, c: cCurr});
                    rCurr += dr;
                    cCurr += dc;
                }
                if (rCurr >= 0 && rCurr < 8 && cCurr >= 0 && cCurr < 8 && currentBoard[rCurr][cCurr] === player && potentialFlips.length > 0) {
                    flips = flips.concat(potentialFlips);
                }
            }
            return flips;
        }

        function isValidMove(r, c, player, currentBoard) {
            return getFlips(r, c, player, currentBoard).length > 0;
        }

        function getValidMoves(player, currentBoard) {
            let moves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(r, c, player, currentBoard)) {
                        moves.push({r, c});
                    }
                }
            }
            return moves;
        }

        function makeMove(r, c, player, realMove = true) {
            if (realMove) {
                const flips = getFlips(r, c, player, board);
                board[r][c] = player;
                flips.forEach(p => board[p.r][p.c] = player);
                updateBoardUI(); // 更新棋盘
            } else {
                const newBoard = JSON.parse(JSON.stringify(board)); 
                const flips = getFlips(r, c, player, newBoard);
                newBoard[r][c] = player;
                flips.forEach(p => newBoard[p.r][p.c] = player);
                return newBoard;
            }
        }

        function handleUserClick(r, c) {
            if (isGameOver || isComputerThinking) return;
            if (gameMode === 'pve' && currentPlayer !== humanSide) return;

            if (isValidMove(r, c, currentPlayer, board)) {
                makeMove(r, c, currentPlayer);
                currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
                checkGameState();
            }
        }

        function checkGameState() {
            updateScore();
            
            let validMoves = getValidMoves(currentPlayer, board);
            
            if (validMoves.length === 0) {
                let opponent = currentPlayer === BLACK ? WHITE : BLACK;
                let opponentMoves = getValidMoves(opponent, board);
                
                if (opponentMoves.length === 0) {
                    gameOver();
                    return;
                } else {
                    // Pass 逻辑
                    currentPlayer = opponent;
                    updateBoardUI(); 
                    setTimeout(checkGameState, 500); 
                    return;
                }
            }

            document.getElementById('score-black-container').classList.toggle('active-turn', currentPlayer === BLACK);
            document.getElementById('score-white-container').classList.toggle('active-turn', currentPlayer === WHITE);

            // 显示提示
            let showHints = false;
            if (gameMode === 'pvp') showHints = true;
            if (gameMode === 'pve' && currentPlayer === humanSide) showHints = true;

            if (showHints) {
                showLegalMoves(validMoves);
            }

            if (gameMode === 'pve' && currentPlayer !== humanSide && !isGameOver) {
                isComputerThinking = true;
                setTimeout(computerMove, 600); 
            }
        }

        function showLegalMoves(moves) {
            // 先清除旧提示，但保留棋子
            const existingHints = document.querySelectorAll('.legal-move');
            existingHints.forEach(el => el.remove());

            moves.forEach(m => {
                const cell = document.querySelector(`.cell[data-row='${m.r}'][data-col='${m.c}']`);
                // 只有空格子才加提示
                if(board[m.r][m.c] === EMPTY) {
                    const hint = document.createElement('div');
                    hint.className = 'legal-move';
                    cell.appendChild(hint);
                }
            });
        }

        // --- 核心修改：智能更新UI（消除闪烁 + 翻转） ---
        function updateBoardUI() {
            // 清除所有的提示点，但保留棋子
            const hints = document.querySelectorAll('.legal-move');
            hints.forEach(h => h.remove());

            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                const val = board[r][c];

                // 查找当前格子里的棋子
                let disc = cell.querySelector('.disc');

                if (val === EMPTY) {
                    // 如果数据为空，但UI有棋子（通常不会发生，除非悔棋功能），则移除
                    if (disc) disc.remove();
                    return;
                }

                // 如果格子没棋子，但数据有 -> 创建新棋子
                if (!disc) {
                    disc = document.createElement('div');
                    disc.className = 'disc newly-placed'; // 添加 newly-placed 以触发弹入动画
                    
                    // 创建双面结构
                    const faceFront = document.createElement('div');
                    faceFront.className = 'face black'; // 默认正面是黑
                    const faceBack = document.createElement('div');
                    faceBack.className = 'face white';  // 默认背面是白
                    
                    disc.appendChild(faceFront);
                    disc.appendChild(faceBack);
                    cell.appendChild(disc);
                    
                    // 动画结束后移除类，以免翻转时再次触发缩放动画
                    setTimeout(() => disc.classList.remove('newly-placed'), 300);
                }

                // 根据颜色设置翻转状态
                // 逻辑：正面是黑色(0deg)，背面是白色(180deg)
                // 如果是白色，加上 .flipped 类
                if (val === WHITE) {
                    if (!disc.classList.contains('flipped')) {
                        disc.classList.add('flipped');
                    }
                } else {
                    if (disc.classList.contains('flipped')) {
                        disc.classList.remove('flipped');
                    }
                }
            });
        }

        function updateScore() {
            let blackScore = 0;
            let whiteScore = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] === BLACK) blackScore++;
                    if (board[r][c] === WHITE) whiteScore++;
                }
            }
            document.getElementById('score-black').innerText = blackScore;
            document.getElementById('score-white').innerText = whiteScore;
            return {black: blackScore, white: whiteScore};
        }

        function gameOver() {
            isGameOver = true;
            isComputerThinking = false;
            const scores = updateScore();
            let msg = '';
            if (scores.black > scores.white) msg = "黑方获胜！";
            else if (scores.white > scores.black) msg = "白方获胜！";
            else msg = "平局！";
            
            setTimeout(() => alert(`游戏结束\n${msg}\n黑方: ${scores.black} - 白方: ${scores.white}`), 100);
        }

        // --- AI 逻辑 ---
        function computerMove() {
            if (isGameOver) return;
            let computerSide = currentPlayer; 
            let moves = getValidMoves(computerSide, board);
            
            if (moves.length === 0) return; 

            let bestMove = null;

            if (difficulty === 1) {
                bestMove = moves[Math.floor(Math.random() * moves.length)];
            } else if (difficulty === 2) {
                let maxScore = -Infinity;
                moves.forEach(move => {
                    let flips = getFlips(move.r, move.c, computerSide, board).length;
                    let score = flips + WEIGHTS[move.r][move.c]; 
                    if (score > maxScore) {
                        maxScore = score;
                        bestMove = move;
                    }
                });
            } else {
                let bestVal = -Infinity;
                let depth = 4; 
                moves.sort((a, b) => WEIGHTS[b.r][b.c] - WEIGHTS[a.r][a.c]);

                for (let move of moves) {
                    let tempBoard = simulateMove(board, move.r, move.c, computerSide);
                    let moveVal = minimax(tempBoard, depth - 1, false, -Infinity, Infinity, computerSide);
                    if (moveVal > bestVal) {
                        bestVal = moveVal;
                        bestMove = move;
                    }
                }
            }

            makeMove(bestMove.r, bestMove.c, computerSide);
            currentPlayer = computerSide === BLACK ? WHITE : BLACK;
            isComputerThinking = false;
            checkGameState();
        }

        function simulateMove(currentBoard, r, c, player) {
            let newBoard = currentBoard.map(row => [...row]);
            let flips = getFlips(r, c, player, newBoard);
            newBoard[r][c] = player;
            flips.forEach(p => newBoard[p.r][p.c] = player);
            return newBoard;
        }

        function evaluateBoard(currentBoard, aiSide) {
            let score = 0;
            let aiCount = 0;
            let humanCount = 0;
            let opponentSide = aiSide === BLACK ? WHITE : BLACK;

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === aiSide) {
                        score += WEIGHTS[r][c];
                        aiCount++;
                    } else if (currentBoard[r][c] === opponentSide) {
                        score -= WEIGHTS[r][c];
                        humanCount++;
                    }
                }
            }
            if (aiCount + humanCount > 55) {
                return aiCount - humanCount; 
            }
            return score;
        }

        function minimax(currentBoard, depth, isMaximizing, alpha, beta, aiSide) {
            if (depth === 0) return evaluateBoard(currentBoard, aiSide);
            let opponentSide = aiSide === BLACK ? WHITE : BLACK;
            let player = isMaximizing ? aiSide : opponentSide;
            let moves = getValidMoves(player, currentBoard);

            if (moves.length === 0) {
                let nextPlayer = isMaximizing ? opponentSide : aiSide;
                if (getValidMoves(nextPlayer, currentBoard).length === 0) {
                    let eval = evaluateBoard(currentBoard, aiSide);
                    return eval > 0 ? 10000 : -10000;
                }
                return minimax(currentBoard, depth - 1, !isMaximizing, alpha, beta, aiSide);
            }

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (let move of moves) {
                    let newBoard = simulateMove(currentBoard, move.r, move.c, aiSide);
                    let eval = minimax(newBoard, depth - 1, false, alpha, beta, aiSide);
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (let move of moves) {
                    let newBoard = simulateMove(currentBoard, move.r, move.c, opponentSide);
                    let eval = minimax(newBoard, depth - 1, true, alpha, beta, aiSide);
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        function openRules() { document.getElementById('rulesModal').style.display = 'flex'; }
        function closeRules() { document.getElementById('rulesModal').style.display = 'none'; }
        document.getElementById('rulesModal').addEventListener('click', function(e) {
            if (e.target === this) closeRules();
        });
    </script>
</body>
</html>